[
  {
    "name": "ims01-kara.z",
    "_id": "LYvffn-eM",
    "updatedAt": "2024-03-26T14:07:44.908Z",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "65f06cf03a9633050ec58359",
          "65f06cf03a9633050ec58358",
          "65f06cf03a9633050ec5835a"
        ],
        "fileType": "folder",
        "_id": "65f06cf03a9633050ec5835b",
        "createdAt": "2024-03-26T14:07:44.908Z",
        "updatedAt": "2024-03-26T14:07:44.908Z",
        "id": "65f06cf03a9633050ec5835b"
      },
      {
        "name": "sketch.js",
        "content": "//Attributes:\n//forked from: https://openprocessing.org/sketch/2122715\n//Comments:\n//The author utilizes a set of rules for the automated placement of stairs and floors, and enhances the structure with random decorative elements.\n//Key features:\n//- Building object that dynamically adjusts its form in response to user interactions (mouse clicks) to trigger the generation of new structures.\n//- Shader: adapted from https://openprocessing.org/sketch/1605869 to create a distinctive, stylized aesthetic reminiscent of pixel art or early computer graphics in the final render.\n//- Balance between randomness and structure.\n//- Challenges conventional notions of space and structure but also invites viewers to imagine the endless possibilities inherent in procedural generation\n\n//-----------------------------------------------------------\n// Labyrinth\n// For the WCCChallenge << Improbable architecture >>. Join the discord! https://discord.gg/S8c7qcjw2b\n\n// For this week I wanted to try some architectural designs inspired by Sander Patelski\n// (I love his \"Compositions\" series - https://shop.studiosanderpatelski.nl/), but as always,\n// ended up going in a completely different direction.\n// The buildings are generated following a simple set of rules for placing stairs and floors, then decorated with some random shapes. The building is then rendered and passed to a\n// dithering shader for a nice look\n// Dither shader adapted from https://openprocessing.org/sketch/1605869\n\nlet cw, ch;\nlet building;\nlet gl, test, theShader;\nlet isOrtho, bgGradient, cf;\n// Setup function: initializes the canvas, pixel density, background gradient,\n// the building object, and the shader for the dithering effect.\nfunction setup() {\n  cw = 1000; // Canvas width\n  ch = 1000; // Canvas height\n  createCanvas(cw, ch, WEBGL);\n  pixelDensity(1);\n  createBgGradient(); // Initializes background gradient\n  background(255); // Sets background color to white\n\n  building = new Building(); // Creates a new building object\n  theShader = createFilterShader(frag); // Initializes the dithering shader\n  cf = floor(random(1000)); // Random seed for color fluctuation\n}\n// Draw function: renders the building and applies visual effects each frame.\nfunction draw() {\n  // Set camera perspective\n  if (isOrtho) {\n    ortho();\n  } else {\n    perspective();\n  }\n  // Clear with white background\n  clear();\n  background(255);\n\n  // Draw and scale the background gradient\n  push();\n  translate(0, 0, -ch / 2);\n  scale(2, 2, 1);\n  image(bgGradient, -cw / 2, -ch / 2, cw, ch);\n  pop();\n\n  push();\n  // Position and rotate the building\n  rotateX(-PI / 12);\n  rotateY(PI / 4);\n  rotateY(frameCount * 0.005);\n\n  ambientLight(150);\n  directionalLight(255, 0, 0, 0.25, 0.25, -1);\n  pointLight(0, 255, 0, 0, 0, 0);\n  specularMaterial(200, 200, 200, 40);\n  building._3dDraw();\n  pop();\n\n  colorMode(HSB);\n  let hue = map(sin(frameCount * 0.0015 + cf), -1, 1, 0, 360);\n  let colors = color(hue, 100, 40)._array;\n  colorMode(RGB);\n\n  theShader.setUniform(\"uColor\", colors);\n  theShader.setUniform(\"resolution\", [cw, ch]);\n\n  filter(theShader);\n}\n\nlet opposites = {\n  up: \"down\",\n  down: \"up\",\n  left: \"right\",\n  right: \"left\",\n};\nclass Building {\n  constructor() {\n    this.w = floor(random(10, 12));\n    this.h = floor(random(10, 12));\n    this.numFloors = floor(random(10, 15));\n    this.xSize = random(50, 80);\n    this.zSize = random(50, 80);\n    this.ySize = random(80, 100);\n    this.floors = [];\n    this.initializeCells();\n    this.build();\n  }\n\n  initializeCells() {\n    for (let i = 0; i < this.numFloors; i++) {\n      let _floor = [];\n      for (let y = 0; y < this.h; y++) {\n        let _row = [];\n        for (let x = 0; x < this.w; x++) {\n          _row.push({\n            type: \"empty\",\n            x,\n            y,\n            floor: i,\n            decorations: [],\n          });\n        }\n        _floor.push(_row);\n      }\n      this.floors.push(_floor);\n    }\n  }\n\n  getCell(floor, x, y) {\n    if (floor < 0 || floor >= this.numFloors) {\n      return null;\n    }\n    let _floor = this.floors[floor];\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) {\n      return null;\n    }\n    return _floor[y][x];\n  }\n\n  build() {\n    let numFloors = this.numFloors;\n\n    for (let i = 0; i < numFloors; i++) {\n      this.restrictFloor(i);\n      this.populateFloor(i);\n      this.buildFloor(i);\n      if (i === numFloors - 1) {\n        this.cleanStairs(i); // Remove all stairs from last floor\n      }\n    }\n    // All cells that remain empty on the first floor, fill with floor\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(0, x, y);\n        if (cell.type === \"empty\" || cell.type === \"stairsEnd\") {\n          cell.type = \"floor\";\n        }\n      }\n    }\n    // Decorate floors\n    for (let i = 0; i < numFloors; i++) {\n      this.decorateFloor(i);\n    }\n  }\n\n  decorateFloor(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        // If cell is a floor type, and the cell below is also a floor type, add a column\n        let cell = this.getCell(_floorNumber, x, y);\n        let aboveCell = this.getCell(_floorNumber + 1, x, y);\n        if (cell.type === \"floor\" && aboveCell && aboveCell.type === \"floor\") {\n          if (random() < 0.8) {\n            cell.decorations.push({ type: \"column\" });\n          }\n        } else if (cell.type === \"floor\") {\n          if (random() < 0.2) {\n            let cx = random(0.3, 0.7);\n            let cy = random(0.3, 0.7);\n            let h = random(0.2, 0.3);\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 20;\n            let thickness = size / random(2, 4);\n            cell.decorations.push({ type: \"pot\", cx, cy, h, size, thickness });\n          } else if (random() < 0.2) {\n            let cx = random(0.3, 0.7);\n            let cy = random(0.3, 0.7);\n            let h = random(0.3, 0.7);\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 8;\n            let thickness = size / random(2, 4);\n            cell.decorations.push({\n              type: \"sphere\",\n              cx,\n              cy,\n              h,\n              size,\n              thickness,\n            });\n          } else if (random() < 0.15) {\n            cell.decorations.push({ type: \"box\", scale: random(0.7, 1.1) });\n          }\n        }\n      }\n    }\n  }\n\n  restrictFloor(_floorNumber) {\n    let numRingsX = map(_floorNumber, 0, this.numFloors, 0, this.w / 6);\n    let numRingsY = map(_floorNumber, 0, this.numFloors, 0, this.h / 6);\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y);\n        if (\n          x < numRingsX ||\n          x >= this.w - numRingsX ||\n          y < numRingsY ||\n          y >= this.h - numRingsY\n        ) {\n          cell.type = \"locked\";\n        }\n      }\n    }\n  }\n\n  cleanStairs(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y);\n        if (cell.type === \"stairs\") {\n          cell.type = \"empty\";\n        }\n      }\n    }\n  }\n\n  populateFloor(_floorNumber) {\n    if (_floorNumber === 0) {\n      return;\n    }\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let prevCell = this.getCell(_floorNumber - 1, x, y);\n        let cell = this.getCell(_floorNumber, x, y);\n        if (prevCell.type === \"stairsEnd\") {\n          cell.type = \"floor\";\n        }\n      }\n    }\n  }\n\n  buildFloor(_floorNumber) {\n    let requireGround = _floorNumber !== 0;\n    let maxTries = this.w * this.h * 5;\n    let stairsToAdd = floor(this.w * this.h * 0.33);\n    let totalStairs = 0;\n    let _floor = this.floors[_floorNumber];\n    let _prevFloor = _floorNumber > 0 ? this.floors[_floorNumber - 1] : null;\n    // Try to add stairs\n    while (totalStairs < stairsToAdd && maxTries > 0) {\n      let x = floor(random(this.w));\n      let y = floor(random(this.h));\n      let cell = this.getCell(_floorNumber, x, y);\n      let direction = random([\"up\", \"down\", \"left\", \"right\"]);\n      // Can place the stair if the cell is empty, and if the target cell\n      // (after following the direction) is empty and within the bounds of the floor\n      let canPlaceStair = cell.type === \"empty\";\n      let target = null;\n      let source = null;\n      let s = (source) => {\n        return (\n          source &&\n          (requireGround ? source.type === \"floor\" : source.type === \"empty\")\n        );\n      };\n      let f = (source) => {\n        // Check if previous floor has a stair on its source cell that is opposite direction to the current direction\n        if (_prevFloor) {\n          let prevCell = this.getCell(_floorNumber - 1, source.x, source.y);\n          if (prevCell.type === \"stairs\") {\n            return !prevCell.direction === opposites[direction];\n          }\n        }\n        return true;\n      };\n      switch (direction) {\n        case \"up\":\n          source = this.getCell(_floorNumber, x, y + 1);\n          target = this.getCell(_floorNumber, x, y - 1);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y > 0;\n          break;\n        case \"down\":\n          source = this.getCell(_floorNumber, x, y - 1);\n          target = this.getCell(_floorNumber, x, y + 1);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair &&\n            target &&\n            target.type === \"empty\" &&\n            y < this.h - 1;\n          break;\n        case \"left\":\n          source = this.getCell(_floorNumber, x + 1, y);\n          target = this.getCell(_floorNumber, x - 1, y);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x > 0;\n          break;\n        case \"right\":\n          source = this.getCell(_floorNumber, x - 1, y);\n          target = this.getCell(_floorNumber, x + 1, y);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair &&\n            target &&\n            target.type === \"empty\" &&\n            x < this.w - 1;\n          break;\n      }\n      if (canPlaceStair) {\n        cell.type = \"stairs\";\n        cell.direction = direction;\n        target.type = \"stairsEnd\";\n        totalStairs++;\n      }\n      maxTries--;\n    }\n\n    // For each empty cell, if it has a neighbor that is a floor, and there is no\n    // stairs on the floor below, make it a floor with a random diminishing chance\n    let chance = 0.6;\n    let numPasses = 3;\n    for (let i = 0; i < numPasses; i++) {\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(_floorNumber, x, y);\n          let stairsInPrevFloor =\n            !_prevFloor ||\n            this.getCell(_floorNumber - 1, x, y).type === \"stairs\";\n          if (cell.type === \"empty\" && !stairsInPrevFloor) {\n            let neighbors = this.getNeighbors(cell, _floor);\n            for (let neighbor of neighbors) {\n              if (neighbor.type === \"floor\" && random() < chance) {\n                cell.type = \"floor\";\n                cell.added = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n      chance *= 0.5;\n    }\n  }\n\n  getNeighbors(cell) {\n    let directions = [\n      [0, -1],\n      [0, 1],\n      [-1, 0],\n      [1, 0],\n    ];\n    return directions\n      .map((d) => {\n        let [dx, dy] = d;\n        return this.getCell(cell.floor, cell.x + dx, cell.y + dy);\n      })\n      .filter((c) => c);\n  }\n\n  _3dDraw(buffer) {\n    let xSize = this.xSize;\n    let ySize = this.ySize;\n    let zSize = this.zSize;\n    push();\n    // Translate so the building is centered\n    let totalW = this.w * xSize;\n    let totalH = this.floors.length * ySize;\n    let totalD = this.h * zSize;\n    translate(-totalW / 2, (totalH / 2) * 0.8, -totalD / 2);\n    for (let i = 0; i < this.floors.length; i++) {\n      push();\n      translate(0, -i * ySize, 0);\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(i, x, y);\n          push();\n          translate(cell.x * xSize, 0, cell.y * zSize);\n          stroke(\"#0C213A\");\n          let r = noise(cell.x, cell.y, i);\n          let sw = map(r, 0, 1, 0.5, 3);\n          strokeWeight(sw);\n\n          let c = r < 0.5 ? \"#303030\" : \"#909090\";\n          fill(c);\n\n          if (cell.type === \"floor\") {\n            this._drawFloor(buffer, cell);\n            this._drawDecor(buffer, cell);\n          } else if (cell.type === \"stairs\") {\n            this._drawStairs(buffer, cell);\n          }\n\n          pop();\n        }\n      }\n      pop();\n    }\n    pop();\n  }\n\n  _drawPot(buffer, d) {\n    let cx = d.cx * this.xSize;\n    let cy = d.cy * this.zSize;\n    let h = d.h * this.ySize;\n    push();\n    noStroke();\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2);\n    translate(cx, 0, cy);\n    let b = d.thickness;\n\n    // Bottom\n    push();\n    translate(0, h / 2, 0);\n    box(d.size, b, d.size);\n    pop();\n    // Left\n    push();\n    translate(-d.size / 2, 0, 0);\n    box(b, h, d.size);\n    pop();\n    // Right\n    push();\n    translate(d.size / 2, 0, 0);\n    box(b, h, d.size);\n    pop();\n    // Front\n    push();\n    translate(0, 0, -d.size / 2);\n    box(d.size, h, b);\n    pop();\n    // Back\n    push();\n    translate(0, 0, d.size / 2);\n    box(d.size, h, b);\n    pop();\n\n    pop();\n  }\n\n  _drawSphere(buffer, d) {\n    let cx = d.cx * this.xSize;\n    let cy = d.cy * this.zSize;\n    let h = d.h * this.ySize;\n    let b = d.thickness;\n    let speed = map(noise(d.cx, d.cy, d.h, frameCount * 0.01), 0, 1, 0.01, 0.1);\n    let r = map(sin(frameCount * speed), -1, 1, 0.8, 1.5);\n    push();\n    noStroke();\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2);\n    translate(cx, 0, cy);\n    translate(0, -h / 2, 0);\n    sphere(b * r);\n    pop();\n  }\n\n  _drawDecor(buffer, cell) {\n    for (let d of cell.decorations) {\n      switch (d.type) {\n        case \"column\":\n          push();\n          // Make a cylinder column in the middle of the cell\n          noStroke();\n          cylinder(max(this.xSize / 6, this.zSize / 6), this.ySize - 4);\n          pop();\n          break;\n        case \"pot\":\n          this._drawPot(buffer, d);\n          break;\n        case \"sphere\":\n          this._drawSphere(buffer, d);\n          break;\n        case \"box\":\n          push();\n          noFill();\n          // translate(-this.xSize / 2, this.ySize / 2, -this.ySize / 2)\n          scale(d.scale);\n          strokeWeight(1);\n          box(this.xSize, this.ySize, this.zSize);\n          pop();\n          break;\n      }\n    }\n  }\n\n  _drawStairs(buffer, cell) {\n    let numSteps = 10;\n    let width =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize;\n    let length =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize;\n    let stepSize = length / numSteps;\n    let stepHeight = this.ySize / numSteps;\n    push();\n    strokeWeight(1);\n    translate(0, this.ySize / 2, 0);\n    switch (cell.direction) {\n      case \"up\":\n        break;\n      case \"down\":\n        rotateY(PI);\n        break;\n      case \"left\":\n        rotateY(PI / 2);\n        break;\n      case \"right\":\n        rotateY(-PI / 2);\n        break;\n    }\n    for (let i = 0; i < numSteps; i++) {\n      push();\n      translate(0, 0, length / 2 - 2 * stepSize);\n      translate(0, -i * stepHeight, -i * stepSize + stepSize);\n      box(width, 4, stepSize * 2);\n      pop();\n    }\n    pop();\n  }\n\n  _drawStairs2(buffer, cell) {\n    push();\n    let e =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize;\n    let f =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize;\n    let d = sqrt(f * f + this.ySize * this.ySize);\n\n    switch (cell.direction) {\n      case \"up\":\n        break;\n      case \"down\":\n        rotateY(PI);\n        break;\n      case \"left\":\n        rotateY(PI / 2);\n        break;\n      case \"right\":\n        rotateY(-PI / 2);\n        break;\n    }\n    // Determine the angle of the plane, on the triangle formed by the diagonal of the box and the height\n    let angle = atan(this.ySize / f);\n    rotateX(-angle);\n    box(e, 2, d);\n    pop();\n  }\n\n  _drawFloor(buffer, cell) {\n    push();\n    translate(0, this.ySize / 2, 0);\n    if (cell.added) {\n      let d = noise(cell.x, cell.y, cell.floor, frameCount * 0.01);\n      if (d < 0.5) {\n        fill(\"#30303010\");\n      }\n    }\n    box(this.xSize, 2, this.zSize);\n    pop();\n  }\n\n  _drawArrow(x, y, direction) {\n    push();\n    translate(x, y);\n    switch (direction) {\n      case \"up\":\n        rotate(PI);\n        break;\n      case \"down\":\n        break;\n      case \"left\":\n        rotate(PI / 2);\n        break;\n      case \"right\":\n        rotate(-PI / 2);\n        break;\n    }\n    triangle(-5, -5, 5, -5, 0, 5);\n    pop();\n  }\n}\n\nlet createBgGradient = () => {\n  let graphics = createGraphics(cw, ch);\n  graphics.pixelDensity(1);\n  let gradient = graphics.drawingContext.createLinearGradient(\n    cw / 2,\n    0,\n    random(cw),\n    ch\n  );\n  gradient.addColorStop(0, \"#555\");\n  gradient.addColorStop(1, \"#AAA\");\n  graphics.drawingContext.fillStyle = gradient;\n  graphics.rect(0, 0, cw, ch);\n  bgGradient = graphics;\n};\n\nfunction keyPressed() {\n  if (key === \"s\") {\n    saveCanvas(\"screenshot\", \"png\");\n  } else if (key === \"o\") {\n    isOrtho = !isOrtho;\n  }\n}\n\n// Click to generate a new building\nfunction mouseClicked() {\n  building = new Building();\n  createBgGradient();\n  cf = floor(random(1000));\n}\n\n//==============================================================================\n// Shader\n//==============================================================================\n\n// Shader adapted from https://openprocessing.org/sketch/1605869\nlet frag = `\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform vec3 uColor;\nuniform sampler2D tex0;\n\nconst float Threshold = 0.5;\nconst float Multiplicator = 1.0 / 17.0;\nconst mat4 DitherMatrix = (mat4(\n    1, 13, 4, 16,\n    9, 5, 12, 8,\n    3, 15, 2, 14,\n    11, 7, 10, 6\n    ) - 8.) * Multiplicator;\n\nfloat GetLuminance(vec4 c) {\n  return (0.2126*c.r + 0.7152*c.g + 0.0722*c.b);\n}\n\nfloat AdjustDither( float val, vec2 coord ) {\n    vec2 coordMod = mod(coord, 4.0);\n    int xMod = int(coordMod.x);\n    int yMod = int(coordMod.y);\n\n    vec4 col;\n    if (xMod == 0) col = DitherMatrix[0];\n    else if (xMod == 1) col = DitherMatrix[1];\n    else if (xMod == 2) col = DitherMatrix[2];\n    else if (xMod == 3) col = DitherMatrix[3];\n\n    float adjustment = 0.;\n    if (yMod == 0) adjustment = col.x;\n    else if (yMod == 1) adjustment = col.y;\n    else if (yMod == 2) adjustment = col.z;\n    else if (yMod == 3) adjustment = col.w;\n\n    return val + (val * adjustment);\n}\n\nvoid main (void) {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec4 c = texture2D(tex0, uv);\n\n  float luminance = GetLuminance(c);\n\n  if (AdjustDither(luminance, uv*resolution)>Threshold) {\n    gl_FragColor = vec4(1., 1., 1., 1.);\n  } else {\n    // gl_FragColor = vec4(0., 0., 0., 1.);\n    gl_FragColor = vec4(uColor, 1.);\n  }\n}`;\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec58358",
        "isSelectedFile": true,
        "createdAt": "2024-03-26T14:07:44.908Z",
        "updatedAt": "2024-03-26T14:07:44.908Z",
        "id": "65f06cf03a9633050ec58358"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/addons/p5.sound.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n    <meta charset=\"utf-8\" />\n\n  </head>\n  <body>\n    <main>\n    </main>\n    <script src=\"sketch.js\"></script>\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec58359",
        "createdAt": "2024-03-26T14:07:44.908Z",
        "updatedAt": "2024-03-26T14:07:44.908Z",
        "id": "65f06cf03a9633050ec58359"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec5835a",
        "createdAt": "2024-03-26T14:07:44.908Z",
        "updatedAt": "2024-03-26T14:07:44.908Z",
        "id": "65f06cf03a9633050ec5835a"
      }
    ],
    "createdAt": "2024-03-12T15:39:43.874Z",
    "id": "LYvffn-eM"
  },
  {
    "name": "ims03-kara.z",
    "_id": "Mtdn3z1CO",
    "updatedAt": "2024-04-09T15:04:07.393Z",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "6614450989ee391f25b43acc",
          "6614450989ee391f25b43acb",
          "6614450989ee391f25b43acd"
        ],
        "fileType": "folder",
        "_id": "6614450989ee391f25b43ace",
        "createdAt": "2024-04-09T15:04:07.393Z",
        "updatedAt": "2024-04-09T15:04:07.393Z",
        "id": "6614450989ee391f25b43ace"
      },
      {
        "name": "sketch.js",
        "content": "//https://editor.p5js.org/karakkzzk/sketches/Mtdn3z1CO\n//ims03-kara.z\n\n//Attributes: “Event Horizon” by KomaTebehttp://openprocessing.org/sketch/2130260License CreativeCommons Attribution NonCommercial ShareAlikehttps://creativecommons.org/licenses/by-nc-sa/3.0\n\n//comments:\n//This modified sketch is an intriguing expansion on the original \"Event Horizon\" by KomaTebe, enhancing interactivity and adaptability through several key modifications. Here's a breakdown of the changes you've made and their implications on the sketch's functionality and user experience:\n\n//Dynamic Canvas Sizing\n//By setting the canvas size to windowWidth and windowHeight, you've made the sketch responsive to the browser window's dimensions. This ensures that the visual experience is optimized across different devices and screen sizes, a significant enhancement over a static canvas size. The windowResized() function further improves this by dynamically adjusting the canvas size as the browser window changes, maintaining the sketch's integrity throughout user interaction.\n\n//Date-Based Visual Variation\n//Integrating the current date into the sketch's visual output introduces a dynamic element that changes daily. By using the day, month, and year to influence the background color and rotation speed, the sketch presents a unique experience each day. This temporal element adds a layer of depth, making each interaction with the sketch not just responsive to screen size but also to time.\n\n//Fullscreen Interactivity\n//The addition of a fullscreen toggle button significantly enhances user engagement with the sketch. By allowing users to switch between fullscreen and windowed modes, you provide a more immersive experience. This feature is particularly impactful for visual sketches like this one, where the scale of the visuals can dramatically affect the viewer's experience. The button's dynamic label change (\"Full Screen\" / \"Windowed\") based on the fullscreen state is a thoughtful touch, improving the UI's intuitiveness.\n\nlet f=0;\nlet now;\nlet day, month, year;\nlet fullscreenBtn; // Button for toggling fullscreen\n\nfunction setup(){\n  createCanvas(windowWidth, windowHeight); // Set the canvas to fill the window\n  now = new Date();\n  day = now.getDate();\n  month = now.getMonth() + 1;\n  year = now.getFullYear();\n  \n  fullscreenBtn = createButton('Full Screen'); // Create the full screen button\n  fullscreenBtn.position(10, 10); // Position the button\n  fullscreenBtn.mousePressed(toggleFullscreen); // Specify the action on click\n}\n\nfunction draw(){\n  let W = min(windowWidth, windowHeight); // Use the smaller dimension for square canvas behavior\n  background(month*10, day*2, year%100);\n  translate(width/2, height/2); // Center the drawing in the canvas\n  rotate(f/W * (day/15));\n  \n  if(W > 0){\n    for(let z=255; z>=0; z-=2){\n      for(let i=0;i<TAU;i+=PI/64){ \n        let n=noise(i, tan(i)/90000, (f+z)/100);\n        push();\n        rotate(i);\n        stroke(W-z);\n        point(0, z*n);\n        stroke(W, 77);\n        point(z-n*W, i*12);\n        pop();\n      }\n    }\n  }\n  f-=2;\n}\n\n// Toggle between full screen and windowed mode\nfunction toggleFullscreen() {\n  let fs = fullscreen();\n  fullscreen(!fs);\n  if (!fs) {\n    fullscreenBtn.hide(); // Hide the button when entering fullscreen mode\n  } else {\n    fullscreenBtn.show(); // This line is more theoretical unless you're toggling fullscreen status elsewhere\n  }\n}\n\n// Adjust canvas size dynamically when the window is resized\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n}\n\n\n// ----------------------------------------\n// Minimized\n// ----------------------------------------\n// f=0,draw=t=>{if(f||createCanvas(W=400,W),background(0),r=W,translate(200,200),rotate(f/W),r>0)for(z=255;z>=0;z-=2)for(i=0;i<TAU;i+=PI/64)push(n=noise(i,tan(i)/9e4,(f+z)/100)),rotate(i),stroke(W-z),point(0,z*n),stroke(W,77),point(z-n*W,12*i),pop(),r--;f-=2};//#つぶやきProcessing",
        "children": [],
        "fileType": "file",
        "_id": "6614450989ee391f25b43acb",
        "isSelectedFile": true,
        "createdAt": "2024-04-09T15:04:07.393Z",
        "updatedAt": "2024-04-09T15:04:07.393Z",
        "id": "6614450989ee391f25b43acb"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/addons/p5.sound.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n    <meta charset=\"utf-8\" />\n\n  </head>\n  <body>\n    <main>\n    </main>\n    <script src=\"sketch.js\"></script>\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "6614450989ee391f25b43acc",
        "createdAt": "2024-04-09T15:04:07.393Z",
        "updatedAt": "2024-04-09T15:04:07.393Z",
        "id": "6614450989ee391f25b43acc"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "6614450989ee391f25b43acd",
        "createdAt": "2024-04-09T15:04:07.393Z",
        "updatedAt": "2024-04-09T15:04:07.393Z",
        "id": "6614450989ee391f25b43acd"
      }
    ],
    "createdAt": "2024-04-08T19:32:43.814Z",
    "id": "Mtdn3z1CO"
  },
  {
    "name": "ims04-kara.z",
    "_id": "aD2bqoiLh",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "661d6a69d817dd8be0f2e6b4",
          "661d6a69d817dd8be0f2e6b5",
          "661d6a69d817dd8be0f2e6b6",
          "661d6a69d817dd8be0f2e6b7",
          "661d6a69d817dd8be0f2e6b8",
          "661d6a69d817dd8be0f2e6b9"
        ],
        "fileType": "folder",
        "_id": "661d6a69d817dd8be0f2e6b3",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b3"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b8",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b8"
      },
      {
        "name": "a_my_init.js",
        "content": "//\nfunction my_init() {\n  // updated to verify change on mobile\n  my.version = '?v=63';\n  my.isRemote = 1;\n  my.videoFlag = 1;\n  // show detailed log\n  my.logLoud = 0;\n\n  // Aspect ratio of video capture on mobile device\n  my.vwidth = 480 / 2;\n  my.vheight = 640 / 2;\n  my.fireb_config = 'jht9629';\n  // my.fireb_config = 'jht1493';\n  // my.fireb_config = 'jhtitp';\n\n  my.dbase_rootPath = 'm0-@r-@w-';\n  my.mo_app = 'mo-photo';\n  my.roomName = 'room1';\n\n  // my.nameDevice = '';\n\n  if (my.isRemote) {\n    my.width = my.vwidth;\n    my.height = my.vheight;\n  } else {\n    my.width = windowWidth;\n    my.height = windowHeight;\n  }\n\n  my.colorGold = [187, 165, 61];\n  my.colors = [[255, 0, 0], [0, 255, 0], my.colorGold];\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b4",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b4"
      },
      {
        "name": "a_sketch.js",
        "content": "//https://editor.p5js.org/karakkzzk/sketches/aD2bqoiLh\n//ims04-kara.z\n\n// Attributes: https://editor.p5js.org/jht9629-nyu/sketches/5VKqK34Ps\n// p5moExamples photo booth 70\n\n// Capture canvas pixels to cloud as image jpg or png\n\nlet my = {};\n\nfunction setup() {\n  my_init();\n\n  // set group to share cloud data\n  my.group = 'group1';\n\n  my.photo_index = 0;\n  my.photo_max = 4;\n  my.photo_list = [];\n\n  //new\n  my.slit_scan = false;\n  my.pixel_grid = false;\n  my.chip_grid = false;\n\n  // my.imageQuality = 1;\n  my.imageQuality = 0.1;\n  my.imageExt = '.jpg';\n  // my.imageExt = '.png';\n  my.thumbWidth = my.vwidth / 2;\n\n  // Lowest pixel density for small uploads\n  pixelDensity(1);\n\n  my.canvas = createCanvas(my.width, my.height);\n  my.canvas.mouseReleased(canvas_mouseReleased);\n  my.canvas.touchEnded(canvas_mouseReleased);\n\n  ui_init();\n\n  video_create();\n\n  dbase_app_init({ completed: startup_completed });\n\n  // for moving circle or video scan line\n  my.x = 0;\n  my.y = my.height / 2;\n  my.xstep = 1;\n  my.radius = int(my.width / 10);\n  \n}\n\nfunction startup_completed() {\n  //\n  // dbase_devices_observe({ observed_key, observed_item, all: 1 });\n  // dbase_app_observe({ observed_item });\n  dbase_group_observe({ observed_key, observed_item });\n\n  function observed_key(key, device) {\n    // console.log('observed_a_device key', key, 'uid', my.uid, 'device', device);\n    // console.log('observed_key key', key, 'device.photo_index', device && device.photo_index);\n  }\n\n  function observed_item(device) {\n    // console.log('observed_item device.photo_index', device.photo_index);\n    // console.log('observed_item device.photo_list', device.photo_list);\n    if (device.photo_list != undefined) {\n      my.photo_list = device.photo_list;\n    }\n    if (device.photo_index != undefined) {\n      my.photo_index = device.photo_index;\n    }\n    show_action();\n  }\n}\n\nfunction ui_init() {\n  // Button to revert to normal view\n  my.normalViewButton = createButton('Normal');\n  my.normalViewButton.mousePressed(() => {\n    my.slit_scan = false;\n    my.pixel_grid = false;\n    my.chip_grid = false;\n  });\n  \n  // Button to toggle slit-scan effect\n  my.slitScanButton = createButton('Slit-Scan');\n  my.slitScanButton.mousePressed(() => my.slit_scan = !my.slit_scan);\n\n  // Button for pixel-grid effect\n  my.pixelGridButton = createButton('Pixel-Grid');\n  my.pixelGridButton.mousePressed(() => {\n    my.pixel_grid = true;\n    my.slit_scan = false;\n    my.chip_grid = false;\n  });\n\n  // Button for mo-pix-chip-grid effect\n  my.chipGridButton = createButton('Mo-Pix-Chip-Grid');\n  my.chipGridButton.mousePressed(() => {\n    my.chip_grid = true;\n    my.slit_scan = false;\n    my.pixel_grid = false;\n  });\n  // Save Photo button\n  my.savePhotoButton = createButton('Save Photo');\n  my.savePhotoButton.mousePressed(savePhoto);\n\n  \n  my.photo_count_span = createSpan('Photos: 0');\n  my.photo_count_span.position(10, my.height + 50); \n}\n\nfunction savePhoto() {\n  saveCanvas(my.canvas, 'myPhoto', my.imageExt);\n}\n\n\nfunction draw() {\n  draw_frame();\n  //draw_number(my.photo_index + 1);\n}\n\nfunction draw_frame() {\n  if (my.videoFlag && !video_ready()) return;\n\n  my.videoImg = my.videoFlag ? my.video.get() : null;\n  if (!my.videoImg) return;\n\n  if (my.slit_scan) {\n    draw_scan();\n  } else if (my.pixel_grid) {\n    draw_pixel_grid();\n  } else if (my.chip_grid) {\n    draw_chip_grid();\n  } else {\n    draw_video();\n  }\n\n  my.x = (my.x + my.xstep) % my.width;\n\n  //let str = my.photo_list.length + ' ' + my.photo_index;\n  //my.photo_count_span.html(str);\n}\n\n\nfunction draw_scan() {\n  // my.videoImg.loadPixels();\n  let w = my.videoImg.width;\n  let h = my.videoImg.height;\n  copy(my.videoImg, w / 2, 0, 1, h, my.x, 0, 1, h);\n}\nfunction draw_pixel_grid() {\n  let gridSize = 20; // Size of each grid cell\n  let cols = floor(my.width / gridSize);\n  let rows = floor(my.height / gridSize);\n  for (let i = 0; i < cols; i++) {\n    for (let j = 0; j < rows; j++) {\n      let x = i * gridSize;\n      let y = j * gridSize;\n      let c = my.videoImg.get(x + gridSize / 2, y + gridSize / 2);\n      fill(c);\n      noStroke();\n      rect(x, y, gridSize, gridSize);\n    }\n  }\n}\n\nfunction draw_chip_grid() {\n  let chipSize = 10; // Size of each chip cell\n  let cols = floor(my.width / chipSize);\n  let rows = floor(my.height / chipSize);\n  for (let i = 0; i < cols; i++) {\n    for (let j = 0; j < rows; j++) {\n      let x = i * chipSize;\n      let y = j * chipSize;\n      let c = my.videoImg.get(x + chipSize / 2, y + chipSize / 2);\n      fill(c);\n      stroke(0); // Black borders for chips\n      strokeWeight(0.5);\n      rect(x, y, chipSize, chipSize);\n    }\n  }\n}\n\n\nfunction draw_video() {\n  // background(0);\n  image(my.videoImg, 0, 0);\n  // Draw circle on video\n  noStroke();\n  let index = my.photo_index + 1;\n  fill(my.colors[index % my.colors.length]);\n  circle(my.x, my.y, my.radius);\n}\n\nfunction draw_number(n) {\n  // Convert number to string\n  let str = n + '';\n  let x = 10;\n  let y = my.height;\n  textSize(50);\n  // Draw black rect background\n  let a = textAscent();\n  let d = textDescent();\n  let h = a + d;\n  let w = textWidth(str);\n  fill(0);\n  //rect(x, y - h, w, h);\n  // Draw white text\n  fill(255);\n  // x  y bottom-left corner.\n  text(str, x, y - d);\n}\n\nfunction canvas_mouseReleased() {\n  // console.log('canvas_mouseReleased');\n  track_xy();\n}\n\nfunction track_xy() {\n  let x = mouseX;\n  let y = mouseY;\n}\n\nfunction mouseDragged() {\n  // console.log('mouseDragged');\n  // required to prevent touch drag moving canvas on mobile\n  let onCanvas = mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height;\n  if (onCanvas) {\n    track_xy();\n  }\n  // return my.scrollFlag ? true : !onCanvas;\n  return !onCanvas;\n}\n\nfunction windowResized() {\n  // console.log('windowResized windowHeight', windowHeight, 'windowWidth', windowWidth);\n  // my.isPortrait = windowHeight > windowWidth;\n  if (my.isRemote) {\n    return;\n  }\n  resizeCanvas(windowWidth, windowHeight);\n  // console.log('windowResized width', width, 'height', height);\n}\n\n// https://editor.p5js.org/jht9629-nyu/sketches/twgS6eWRZ\n// pixel-grid\n\n// https://editor.p5js.org/jht9629-nyu/sketches/7Wjlo3pPU\n// mo-pix-chip-grid jht9629 fireb_firebase.js\n\n// https://editor.p5js.org/jht9629-nyu/sketches/CntV1JQNp\n// p5moExamples pixel-grid 47\n\n// [x] Correct display of images - must hit show button\n// [x] Add --> Take, keep array of n images and upate\n// [x] photo_index\n\n// [x] my.photo_list - show only last n\n//    [ { name: \"\", index: n }, ... ]\n\n// [x] preserve image show order\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b5",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": true,
        "id": "661d6a69d817dd8be0f2e6b5"
      },
      {
        "name": "photo.js",
        "content": "//\n\nfunction photo_name(index) {\n  return index.toString().padStart(3, '0') + my.imageExt;\n}\n\nfunction photo_list_entry(index) {\n  let name = photo_name(index);\n  let uid = my.uid;\n  return { name, index, uid };\n}\n\nfunction photo_path_entry(entry) {\n  return entry.uid + '/' + entry.name;\n}\n\nasync function photo_list_add(entry) {\n  my.photo_list.push(entry);\n  if (my.photo_list.length > my.photo_max) {\n    await photo_list_trim();\n  }\n\n  // Change to photo_list send to cloud\n  dbase_group_update({ photo_list: my.photo_list });\n}\n\nasync function photo_list_trim() {\n  //\n  // remove the first entry in photo_list\n  //\n  let first = my.photo_list.shift();\n  await photo_list_remove_entry(first);\n}\n\nasync function photo_list_remove_entry(entry) {\n  // console.log('photo_list_remove_entry entry', entry);\n\n  let path = photo_path_entry(entry);\n  try {\n    await fstorage_remove({ path });\n    remove_img_index(entry.index);\n  } catch (err) {\n    console.log('show_action err', err);\n  }\n}\n\nfunction remove_img_index(index) {\n  // console.log('remove_img_index index', index);\n  let id = 'id_img_' + index;\n  let img = select('#' + id);\n  // console.log('remove_img_index img', img);\n  if (img) {\n    img.remove();\n  }\n}\n\nasync function show_action() {\n  //\n  // console.log('show_action my.photo_list', my.photo_list);\n  for (let entry of my.photo_list) {\n    let path = photo_path_entry(entry);\n    try {\n      let url = await fstorage_download_url({ path });\n      url_result(url, entry.index);\n    } catch (err) {\n      console.log('show_action err', err);\n    }\n  }\n  function url_result(url, index) {\n    // console.log('url_result index', index, 'url', url);\n    let img = find_img(index);\n    img.elt.src = url;\n  }\n}\n\n// Create image element for an index\n//  or return if already present\n//\nfunction find_img(index) {\n  let id = 'id_img_' + index;\n  let img = select('#' + id);\n  if (!img) {\n    // console.log('show_action id', id);\n    img = createImg('', 'image');\n    img.id(id);\n    // console.log('show_action createImg', img);\n    // my.gallery_div.child(img);\n\n    // Add image as first child to see most recent first\n    my.gallery_div.elt.prepend(img.elt);\n\n    let iwidth = my.thumbWidth;\n    img.style('width: ' + iwidth + 'px;');\n  }\n  return img;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b7",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b7"
      },
      {
        "name": "ui_init.js",
        "content": "//\nfunction ui_init() {\n  //\n  my.effectBtn = ui_createButton('Effect');\n  my.effectBtn.mousePressed(effect_action);\n\n  my.takeBtn = ui_createButton('Take');\n  my.takeBtn.mousePressed(take_action);\n\n  my.removeBtn = ui_createButton('Remove');\n  my.removeBtn.mousePressed(remove_action);\n\n  my.showBtn = ui_createButton('Show');\n  my.showBtn.mousePressed(show_action);\n\n  my.photo_count_span = createSpan('' + my.photo_list.length);\n\n  my.gallery_div = ui_div_empty('igallery');\n}\n\nfunction effect_action() {\n  my.slit_scan = !my.slit_scan;\n}\n\nasync function take_action() {\n  // console.log('take_action');\n\n  let entry = photo_list_entry(my.photo_index + 1);\n  let path = photo_path_entry(entry);\n\n  let layer = my.canvas;\n  let imageQuality = my.imageQuality;\n  try {\n    await fstorage_upload({ path, layer, imageQuality });\n\n    await photo_list_add(entry);\n\n    dbase_group_update({ photo_index: dbase_increment(1) });\n    //\n  } catch (err) {\n    console.log('take_action err', err);\n  }\n}\n\nasync function remove_action() {\n  // console.log('remove_action photo_count', my.photo_list.length);\n  if (my.photo_list.length < 1) {\n    // No more images in the cloud\n    //  zero out photo_index\n    dbase_group_update({ photo_index: 0 });\n    return;\n  }\n  //\n  // remove the last entry in photo_list\n  //\n  let last = my.photo_list.pop();\n  await photo_list_remove_entry(last);\n\n  // Update photo_list in the cloud\n  dbase_group_update({ photo_list: my.photo_list });\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b9",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b9"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\"></script>\n    <!-- <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js\"></script> -->\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://molab-itp.github.io/p5moRelease/lib/66/style.css\"></script>\n    <!-- <link rel=\"stylesheet\" type=\"text/css\" href=\"../../../p5moLibrary/src/lib/style.css?v=63\" /> -->\n\n    <style></style>\n  </head>\n  <body>\n    <main></main>\n\n    <script type=\"module\" src=\"https://molab-itp.github.io/p5moRelease/lib/70/a_lib.js\"></script>\n    <!-- <script type=\"module\" src=\"../../p5moLibrary/src/lib/a_lib.js\"></script> -->\n\n    <script src=\"a_my_init.js\"></script>\n    <script src=\"ui_init.js\"></script>\n    <script src=\"photo.js\"></script>\n    <script src=\"a_sketch.js\"></script>\n    <!-- ?v=63 included to force into the cache -->\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "661d6a69d817dd8be0f2e6b6",
        "updatedAt": "2024-04-15T18:18:37.768Z",
        "createdAt": "2024-04-15T18:18:37.768Z",
        "isSelectedFile": false,
        "id": "661d6a69d817dd8be0f2e6b6"
      }
    ],
    "createdAt": "2024-04-15T17:56:57.216Z",
    "updatedAt": "2024-04-15T18:18:37.768Z",
    "id": "aD2bqoiLh"
  },
  {
    "name": "Innovative crafter",
    "_id": "OcjJ4foZE",
    "updatedAt": "2024-04-08T17:59:45.977Z",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "66021dabfbc17f1fd20ddb17",
          "66021dabfbc17f1fd20ddb16",
          "66021dabfbc17f1fd20ddb18"
        ],
        "fileType": "folder",
        "_id": "66021dabfbc17f1fd20ddb19",
        "createdAt": "2024-04-08T17:59:45.977Z",
        "updatedAt": "2024-04-08T17:59:45.977Z",
        "isSelectedFile": false,
        "id": "66021dabfbc17f1fd20ddb19"
      },
      {
        "name": "sketch.js",
        "content": "\n//Attributes:\n//forked from: https://openprocessing.org/sketch/2122715\n//Comments:\n//The author utilizes a set of rules for the automated placement of stairs and floors, and enhances the structure with random decorative elements.\n//Key features: \n//- Building object that dynamically adjusts its form in response to user interactions (mouse clicks) to trigger the generation of new structures.\n//- Shader: adapted from https://openprocessing.org/sketch/1605869 to create a distinctive, stylized aesthetic reminiscent of pixel art or early computer graphics in the final render.\n//- Balance between randomness and structure.\n//- Challenges conventional notions of space and structure but also invites viewers to imagine the endless possibilities inherent in procedural generation\n\n\n\n//-----------------------------------------------------------\n// Labyrinth\n// For the WCCChallenge << Improbable architecture >>. Join the discord! https://discord.gg/S8c7qcjw2b\n\n// For this week I wanted to try some architectural designs inspired by Sander Patelski \n// (I love his \"Compositions\" series - https://shop.studiosanderpatelski.nl/), but as always,\n// ended up going in a completely different direction.\n// The buildings are generated following a simple set of rules for placing stairs and floors,\n// then decorated with some random shapes. The building is then rendered and passed to a\n// dithering shader for a nice look\n// Dither shader adapted from https://openprocessing.org/sketch/1605869\n\nlet cw, ch\nlet building\nlet gl, test, theShader\nlet isOrtho, bgGradient, cf\nlet fullScreenBtn;\nfunction setup() {\n  // Use window dimensions for canvas size\n  cw = windowWidth;\n  ch = windowHeight;\n  createCanvas(cw, ch, WEBGL);\n  pixelDensity(1);\n  createBgGradient(); // Make sure this function adapts to new cw and ch\n  background(255);\n  lastChangeTime = millis();\n\n  building = new Building();\n  theShader = createFilterShader(frag);\n  cf = floor(random(1000));\n  \n  fullScreenBtn = createButton(\"Full Screen\");\n  fullScreenBtn.mousePressed(full_screen_action);\n  fullScreenBtn.style(\"font-size:42px\");\n}\n\nfunction windowResized() {\n  cw = windowWidth;\n  ch = windowHeight;\n  resizeCanvas(cw, ch);\n  createBgGradient(); // Reinitialize the background gradient with new sizes\n  generateNewScene(); // Assuming this function regenerates the building\n}\n\nfunction full_screen_action() {\n  fullScreenBtn.remove();\n  fullscreen(1);\n  let delay = 3000;\n  setTimeout(ui_present_window, delay);\n}\n\nfunction ui_present_window() {\n  resizeCanvas(windowWidth, windowHeight);\n  // Reinitialize or adjust your sketch elements as needed here\n}\n\n\nfunction draw() {\n  if (isOrtho) {\n    ortho()\n  } else {\n    perspective()\n  }\n\n  clear()\n  background(255)\n  push()\n  translate(0, 0, -ch / 2)\n  scale(2, 2, 1)\n  image(bgGradient, -cw / 2, -ch / 2, cw, ch)\n  pop()\n\n  push()\n  rotateX(-PI / 12)\n  rotateY(PI / 4)\n  rotateY(frameCount * 0.005)\n\n  ambientLight(150)\n  directionalLight(255, 0, 0, 0.25, 0.25, -1)\n  pointLight(0, 255, 0, 0, 0, 0)\n  specularMaterial(200, 200, 200, 40)\n  building._3dDraw()\n  pop()\n\n  colorMode(HSB)\n  let hue = map(sin(frameCount * 0.0015 + cf), -1, 1, 0, 360)\n  let colors = color(hue, 100, 40)._array\n  colorMode(RGB)\n\n  theShader.setUniform(\"uColor\", colors)\n  theShader.setUniform(\"resolution\", [cw, ch])\n\n  filter(theShader)\n    // Automatically change the scene every 5 seconds\n  if (millis() - lastChangeTime > 5000) { // 5000 milliseconds = 5 seconds\n    generateNewScene(); // Call the function to change the scene\n    lastChangeTime = millis(); // Reset the timer for the next change\n  }\n}\n\n\n\nlet opposites = {\n  up: \"down\",\n  down: \"up\",\n  left: \"right\",\n  right: \"left\",\n}\nclass Building {\n  constructor() {\n    this.w = floor(random(10, 12));\n    this.h = floor(random(10, 12));\n    this.numFloors = floor(random(10, 15));\n    // Dynamically adjust the size of the building parts based on canvas size\n    this.xSize = cw / 20; // Example proportion, adjust based on needs\n    this.zSize = ch / 20; // Same as above, for consistency\n    this.ySize = (cw + ch) / 40; // Adjust based on the average of canvas dimensions\n    this.floors = [];\n    this.initializeCells();\n    this.build();\n  }\n\n  initializeCells() {\n    for (let i = 0; i < this.numFloors; i++) {\n      let _floor = []\n      for (let y = 0; y < this.h; y++) {\n        let _row = []\n        for (let x = 0; x < this.w; x++) {\n          _row.push({\n            type: \"empty\",\n            x,\n            y,\n            floor: i,\n            decorations: [],\n          })\n        }\n        _floor.push(_row)\n      }\n      this.floors.push(_floor)\n    }\n  }\n\n  getCell(floor, x, y) {\n    if (floor < 0 || floor >= this.numFloors) {\n      return null\n    }\n    let _floor = this.floors[floor]\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) {\n      return null\n    }\n    return _floor[y][x]\n  }\n\n  build() {\n    let numFloors = this.numFloors\n\n    for (let i = 0; i < numFloors; i++) {\n      this.restrictFloor(i)\n      this.populateFloor(i)\n      this.buildFloor(i)\n      if (i === numFloors - 1) {\n        this.cleanStairs(i) // Remove all stairs from last floor\n      }\n    }\n    // All cells that remain empty on the first floor, fill with floor\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(0, x, y)\n        if (cell.type === \"empty\" || cell.type === \"stairsEnd\") {\n          cell.type = \"floor\"\n        }\n      }\n    }\n    // Decorate floors\n    for (let i = 0; i < numFloors; i++) {\n      this.decorateFloor(i)\n    }\n  }\n\n  decorateFloor(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        // If cell is a floor type, and the cell below is also a floor type, add a column\n        let cell = this.getCell(_floorNumber, x, y)\n        let aboveCell = this.getCell(_floorNumber + 1, x, y)\n        if (cell.type === \"floor\" && aboveCell && aboveCell.type === \"floor\") {\n          if (random() < 0.8) {\n            cell.decorations.push({ type: \"column\" })\n          }\n        } else if (cell.type === \"floor\") {\n          if (random() < 0.2) {\n            let cx = random(0.3, 0.7)\n            let cy = random(0.3, 0.7)\n            let h = random(0.2, 0.3)\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 20\n            let thickness = size / random(2, 4)\n            cell.decorations.push({ type: \"pot\", cx, cy, h, size, thickness })\n          } else if (random() < 0.2) {\n            let cx = random(0.3, 0.7)\n            let cy = random(0.3, 0.7)\n            let h = random(0.3, 0.7)\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 8\n            let thickness = size / random(2, 4)\n            cell.decorations.push({\n              type: \"sphere\",\n              cx,\n              cy,\n              h,\n              size,\n              thickness,\n            })\n          } else if (random() < 0.15) {\n            cell.decorations.push({ type: \"box\", scale: random(0.7, 1.1) })\n          }\n        }\n      }\n    }\n  }\n\n  restrictFloor(_floorNumber) {\n    let numRingsX = map(_floorNumber, 0, this.numFloors, 0, this.w / 6)\n    let numRingsY = map(_floorNumber, 0, this.numFloors, 0, this.h / 6)\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y)\n        if (\n          x < numRingsX ||\n          x >= this.w - numRingsX ||\n          y < numRingsY ||\n          y >= this.h - numRingsY\n        ) {\n          cell.type = \"locked\"\n        }\n      }\n    }\n  }\n\n  cleanStairs(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y)\n        if (cell.type === \"stairs\") {\n          cell.type = \"empty\"\n        }\n      }\n    }\n  }\n\n  populateFloor(_floorNumber) {\n    if (_floorNumber === 0) {\n      return\n    }\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let prevCell = this.getCell(_floorNumber - 1, x, y)\n        let cell = this.getCell(_floorNumber, x, y)\n        if (prevCell.type === \"stairsEnd\") {\n          cell.type = \"floor\"\n        }\n      }\n    }\n  }\n\n  buildFloor(_floorNumber) {\n    let requireGround = _floorNumber !== 0\n    let maxTries = this.w * this.h * 5\n    let stairsToAdd = floor(this.w * this.h * 0.33)\n    let totalStairs = 0\n    let _floor = this.floors[_floorNumber]\n    let _prevFloor = _floorNumber > 0 ? this.floors[_floorNumber - 1] : null\n    // Try to add stairs\n    while (totalStairs < stairsToAdd && maxTries > 0) {\n      let x = floor(random(this.w))\n      let y = floor(random(this.h))\n      let cell = this.getCell(_floorNumber, x, y)\n      let direction = random([\"up\", \"down\", \"left\", \"right\"])\n      // Can place the stair if the cell is empty, and if the target cell\n      // (after following the direction) is empty and within the bounds of the floor\n      let canPlaceStair = cell.type === \"empty\"\n      let target = null\n      let source = null\n      let s = (source) => {\n        return (\n          source &&\n          (requireGround ? source.type === \"floor\" : source.type === \"empty\")\n        )\n      }\n      let f = (source) => {\n        // Check if previous floor has a stair on its source cell that is opposite direction to the current direction\n        if (_prevFloor) {\n          let prevCell = this.getCell(_floorNumber - 1, source.x, source.y)\n          if (prevCell.type === \"stairs\") {\n            return !prevCell.direction === opposites[direction]\n          }\n        }\n        return true\n      }\n      switch (direction) {\n        case \"up\":\n          source = this.getCell(_floorNumber, x, y + 1)\n          target = this.getCell(_floorNumber, x, y - 1)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y > 0\n          break\n        case \"down\":\n          source = this.getCell(_floorNumber, x, y - 1)\n          target = this.getCell(_floorNumber, x, y + 1)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y < this.h - 1\n          break\n        case \"left\":\n          source = this.getCell(_floorNumber, x + 1, y)\n          target = this.getCell(_floorNumber, x - 1, y)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x > 0\n          break\n        case \"right\":\n          source = this.getCell(_floorNumber, x - 1, y)\n          target = this.getCell(_floorNumber, x + 1, y)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x < this.w - 1\n          break\n      }\n      if (canPlaceStair) {\n        cell.type = \"stairs\"\n        cell.direction = direction\n        target.type = \"stairsEnd\"\n        totalStairs++\n      }\n      maxTries--\n    }\n\n    // For each empty cell, if it has a neighbor that is a floor, and there is no\n    // stairs on the floor below, make it a floor with a random diminishing chance\n    let chance = 0.6\n    let numPasses = 3\n    for (let i = 0; i < numPasses; i++) {\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(_floorNumber, x, y)\n          let stairsInPrevFloor =\n            !_prevFloor ||\n            this.getCell(_floorNumber - 1, x, y).type === \"stairs\"\n          if (cell.type === \"empty\" && !stairsInPrevFloor) {\n            let neighbors = this.getNeighbors(cell, _floor)\n            for (let neighbor of neighbors) {\n              if (neighbor.type === \"floor\" && random() < chance) {\n                cell.type = \"floor\"\n                cell.added = true\n                break\n              }\n            }\n          }\n        }\n      }\n      chance *= 0.5\n    }\n  }\n\n  getNeighbors(cell) {\n    let directions = [\n      [0, -1],\n      [0, 1],\n      [-1, 0],\n      [1, 0],\n    ]\n    return directions\n      .map((d) => {\n        let [dx, dy] = d\n        return this.getCell(cell.floor, cell.x + dx, cell.y + dy)\n      })\n      .filter((c) => c)\n  }\n\n  _3dDraw(buffer) {\n    let xSize = this.xSize\n    let ySize = this.ySize\n    let zSize = this.zSize\n    push()\n    // Translate so the building is centered\n    let totalW = this.w * xSize\n    let totalH = this.floors.length * ySize\n    let totalD = this.h * zSize\n    translate(-totalW / 2, (totalH / 2) * 0.8, -totalD / 2)\n    for (let i = 0; i < this.floors.length; i++) {\n      push()\n      translate(0, -i * ySize, 0)\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(i, x, y)\n          push()\n          translate(cell.x * xSize, 0, cell.y * zSize)\n          stroke(\"#0C213A\")\n          let r = noise(cell.x, cell.y, i)\n          let sw = map(r, 0, 1, 0.5, 3)\n          strokeWeight(sw)\n\n          let c = r < 0.5 ? \"#303030\" : \"#909090\"\n          fill(c)\n\n          if (cell.type === \"floor\") {\n            this._drawFloor(buffer, cell)\n            this._drawDecor(buffer, cell)\n          } else if (cell.type === \"stairs\") {\n            this._drawStairs(buffer, cell)\n          }\n\n          pop()\n        }\n      }\n      pop()\n    }\n    pop()\n  }\n\n  _drawPot(buffer, d) {\n    let cx = d.cx * this.xSize\n    let cy = d.cy * this.zSize\n    let h = d.h * this.ySize\n    push()\n    noStroke()\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2)\n    translate(cx, 0, cy)\n    let b = d.thickness\n\n    // Bottom\n    push()\n    translate(0, h / 2, 0)\n    box(d.size, b, d.size)\n    pop()\n    // Left\n    push()\n    translate(-d.size / 2, 0, 0)\n    box(b, h, d.size)\n    pop()\n    // Right\n    push()\n    translate(d.size / 2, 0, 0)\n    box(b, h, d.size)\n    pop()\n    // Front\n    push()\n    translate(0, 0, -d.size / 2)\n    box(d.size, h, b)\n    pop()\n    // Back\n    push()\n    translate(0, 0, d.size / 2)\n    box(d.size, h, b)\n    pop()\n\n    pop()\n  }\n\n  _drawSphere(buffer, d) {\n    let cx = d.cx * this.xSize\n    let cy = d.cy * this.zSize\n    let h = d.h * this.ySize\n    let b = d.thickness\n    let speed = map(noise(d.cx, d.cy, d.h, frameCount * 0.01), 0, 1, 0.01, 0.1)\n    let r = map(sin(frameCount * speed), -1, 1, 0.8, 1.5)\n    push()\n    noStroke()\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2)\n    translate(cx, 0, cy)\n    translate(0, -h / 2, 0)\n    sphere(b * r)\n    pop()\n  }\n\n  _drawDecor(buffer, cell) {\n    for (let d of cell.decorations) {\n      switch (d.type) {\n        case \"column\":\n          push()\n          // Make a cylinder column in the middle of the cell\n          noStroke()\n          cylinder(max(this.xSize / 6, this.zSize / 6), this.ySize - 4)\n          pop()\n          break\n        case \"pot\":\n          this._drawPot(buffer, d)\n          break\n        case \"sphere\":\n          this._drawSphere(buffer, d)\n          break\n        case \"box\":\n          push()\n          noFill()\n          // translate(-this.xSize / 2, this.ySize / 2, -this.ySize / 2)\n          scale(d.scale)\n          strokeWeight(1)\n          box(this.xSize, this.ySize, this.zSize)\n          pop()\n          break\n      }\n    }\n  }\n\n  _drawStairs(buffer, cell) {\n    let numSteps = 10\n    let width =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize\n    let length =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize\n    let stepSize = length / numSteps\n    let stepHeight = this.ySize / numSteps\n    push()\n    strokeWeight(1)\n    translate(0, this.ySize / 2, 0)\n    switch (cell.direction) {\n      case \"up\":\n        break\n      case \"down\":\n        rotateY(PI)\n        break\n      case \"left\":\n        rotateY(PI / 2)\n        break\n      case \"right\":\n        rotateY(-PI / 2)\n        break\n    }\n    for (let i = 0; i < numSteps; i++) {\n      push()\n      translate(0, 0, length / 2 - 2 * stepSize)\n      translate(0, -i * stepHeight, -i * stepSize + stepSize)\n      box(width, 4, stepSize * 2)\n      pop()\n    }\n    pop()\n  }\n\n  _drawStairs2(buffer, cell) {\n    push()\n    let e =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize\n    let f =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize\n    let d = sqrt(f * f + this.ySize * this.ySize)\n\n    switch (cell.direction) {\n      case \"up\":\n        break\n      case \"down\":\n        rotateY(PI)\n        break\n      case \"left\":\n        rotateY(PI / 2)\n        break\n      case \"right\":\n        rotateY(-PI / 2)\n        break\n    }\n    // Determine the angle of the plane, on the triangle formed by the diagonal of the box and the height\n    let angle = atan(this.ySize / f)\n    rotateX(-angle)\n    box(e, 2, d)\n    pop()\n  }\n\n  _drawFloor(buffer, cell) {\n    push()\n    translate(0, this.ySize / 2, 0)\n    if (cell.added) {\n      let d = noise(cell.x, cell.y, cell.floor, frameCount * 0.01)\n      if (d < 0.5) {\n        fill(\"#30303010\")\n      }\n    }\n    box(this.xSize, 2, this.zSize)\n    pop()\n  }\n\n  _drawArrow(x, y, direction) {\n    push()\n    translate(x, y)\n    switch (direction) {\n      case \"up\":\n        rotate(PI)\n        break\n      case \"down\":\n        break\n      case \"left\":\n        rotate(PI / 2)\n        break\n      case \"right\":\n        rotate(-PI / 2)\n        break\n    }\n    triangle(-5, -5, 5, -5, 0, 5)\n    pop()\n  }\n}\n\nlet createBgGradient = () => {\n  let graphics = createGraphics(cw, ch);\n  graphics.pixelDensity(1);\n  // Use cw and ch for gradient dimensions\n  let gradient = graphics.drawingContext.createLinearGradient(cw / 2, 0, cw, ch);\n  gradient.addColorStop(0, \"#555\");\n  gradient.addColorStop(1, \"#AAA\");\n  graphics.drawingContext.fillStyle = gradient;\n  graphics.rect(0, 0, cw, ch);\n  bgGradient = graphics;\n}\n\nfunction keyPressed() {\n  if (key === \"s\") {\n    saveCanvas(\"screenshot\", \"png\")\n  } else if (key === \"o\") {\n    isOrtho = !isOrtho\n  }\n}\n\nfunction generateNewScene() {\n  building = new Building(); // Regenerate the building\n  createBgGradient(); // Recreate background gradient if needed\n  cf = floor(random(1000)); // If needed for randomization in your drawing logic\n}\n\n    \n\n\n//==============================================================================\n// Shader\n//==============================================================================\n\n// Shader adapted from https://openprocessing.org/sketch/1605869\nlet frag = `\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform vec3 uColor;\nuniform sampler2D tex0;\n\nconst float Threshold = 0.5;\nconst float Multiplicator = 1.0 / 17.0;\nconst mat4 DitherMatrix = (mat4(\n    1, 13, 4, 16,\n    9, 5, 12, 8,\n    3, 15, 2, 14,\n    11, 7, 10, 6\n    ) - 8.) * Multiplicator;\n\nfloat GetLuminance(vec4 c) {\n  return (0.2126*c.r + 0.7152*c.g + 0.0722*c.b);\n}\n\nfloat AdjustDither( float val, vec2 coord ) {\n    vec2 coordMod = mod(coord, 4.0);\n    int xMod = int(coordMod.x);\n    int yMod = int(coordMod.y);\n\n    vec4 col;\n    if (xMod == 0) col = DitherMatrix[0];\n    else if (xMod == 1) col = DitherMatrix[1];\n    else if (xMod == 2) col = DitherMatrix[2];\n    else if (xMod == 3) col = DitherMatrix[3];\n\n    float adjustment = 0.;\n    if (yMod == 0) adjustment = col.x;\n    else if (yMod == 1) adjustment = col.y;\n    else if (yMod == 2) adjustment = col.z;\n    else if (yMod == 3) adjustment = col.w;\n\n    return val + (val * adjustment);\n}\n\nvoid main (void) {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec4 c = texture2D(tex0, uv);\n\n  float luminance = GetLuminance(c);\n\n  if (AdjustDither(luminance, uv*resolution)>Threshold) {\n    gl_FragColor = vec4(1., 1., 1., 1.);\n  } else {\n    // gl_FragColor = vec4(0., 0., 0., 1.);\n    gl_FragColor = vec4(uColor, 1.);\n  }\n}`\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb16",
        "isSelectedFile": true,
        "createdAt": "2024-04-08T17:59:45.977Z",
        "updatedAt": "2024-04-08T17:59:45.977Z",
        "id": "66021dabfbc17f1fd20ddb16"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/addons/p5.sound.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n    <meta charset=\"utf-8\" />\n\n  </head>\n  <body>\n    <main>\n    </main>\n    <script src=\"sketch.js\"></script>\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb17",
        "createdAt": "2024-04-08T17:59:45.977Z",
        "updatedAt": "2024-04-08T17:59:45.977Z",
        "isSelectedFile": false,
        "id": "66021dabfbc17f1fd20ddb17"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb18",
        "createdAt": "2024-04-08T17:59:45.977Z",
        "updatedAt": "2024-04-08T17:59:45.977Z",
        "isSelectedFile": false,
        "id": "66021dabfbc17f1fd20ddb18"
      }
    ],
    "createdAt": "2024-03-26T02:11:14.564Z",
    "id": "OcjJ4foZE"
  },
  {
    "name": "p5moExamples photo booth 70 copy",
    "_id": "-v7NuIZk5",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "661d5e46b5786e4d8c78366e",
          "661d5e46b5786e4d8c78366f",
          "661d5e46b5786e4d8c783670",
          "661d5e46b5786e4d8c783671",
          "661d5e46b5786e4d8c783672",
          "661d5e46b5786e4d8c783673"
        ],
        "fileType": "folder",
        "_id": "661d5e46b5786e4d8c78366d",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c78366d"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c783672",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c783672"
      },
      {
        "name": "a_my_init.js",
        "content": "",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c78366e",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": true,
        "id": "661d5e46b5786e4d8c78366e"
      },
      {
        "name": "a_sketch.js",
        "content": "// https://editor.p5js.org/jht9629-nyu/sketches/5VKqK34Ps\n// p5moExamples photo booth 70\n\n// Capture canvas pixels to cloud as image jpg or png\n\n// p5moExamples photo booth 70\n\n// Capture canvas pixels to cloud as image jpg or png\n\nfunction setup() {\n  my_init();\n  my.grayEffect = false; // Initialize this property in the setup\n  my.slit_scan = 0;\n  my.canvas = createCanvas(my.width, my.height);\n  my.canvas.mouseReleased(canvas_mouseReleased);\n  my.canvas.touchEnded(canvas_touchEnded);\n  ui_init();\n  video_create();\n  dbase_app_init({ completed: startup_completed });\n}\n\nfunction ui_init() {\n  effectDropdown = createSelect();\n  effectDropdown.position(10, 10);\n  effectDropdown.option('Normal');\n  effectDropdown.option('Slit Scan');\n  effectDropdown.option('Grayscale');  // Changed to Grayscale\n  effectDropdown.changed(applyEffect);\n}\n\nfunction applyEffect() {\n  let effect = effectDropdown.value();\n  switch (effect) {\n    case 'Normal':\n      my.slit_scan = 0;\n      my.grayEffect = false;  // Ensure grayscale is turned off\n      break;\n    case 'Slit Scan':\n      my.slit_scan = 1;\n      my.grayEffect = false;\n      break;\n    case 'Grayscale':  // Handling the Grayscale effect\n      my.slit_scan = 0;\n      my.grayEffect = true;\n      break;\n  }\n}\n\nfunction draw_video() {\n  if (!my.videoImg) return; // Ensure videoImg is available\n\n  // Apply grayscale filter only if the flag is true\n  if (my.grayEffect) {\n    filter(GRAY);\n  }\n\n  image(my.videoImg, 0, 0);\n\n  if (!my.grayEffect) { // Reset filter effects after drawing the image\n    filter(RESET);\n  }\n}\n\nfunction draw() {\n  clear(); // Ensures the canvas is cleared each frame\n  draw_frame();\n  draw_number(my.photo_index + 1);\n}\n\nfunction draw_scan() {\n  let w = my.videoImg.width;\n  let h = my.videoImg.height;\n  copy(my.videoImg, w / 2, 0, 1, h, my.x, 0, 1, h);\n}\n\nfunction draw_video() {\n  if (my.invertColors) {\n  filter(INVERT); // Apply the invert filter here if the flag is true\n  }\n  image(my.videoImg, 0, 0);\n  image(my.videoImg, 0, 0);\n  noStroke();\n  let index = my.photo_index + 1;\n  fill(my.colors[index % my.colors.length]);\n  circle(my.x, my.y, my.radius);\n}\n\nfunction draw_number(n) {\n  let str = n + '';\n  let x = 10;\n  let y = my.height;\n  textSize(50);\n  let a = textAscent();\n  let d = textDescent();\n  let h = a + d;\n  let w = textWidth(str);\n  fill(0);\n  rect(x, y - h, w, h);\n  fill(255);\n  text(str, x, y - d);\n}\n\nfunction canvas_mouseReleased() {\n  track_xy();\n}\n\nfunction track_xy() {\n  let x = mouseX;\n  let y = mouseY;\n}\n\nfunction mouseDragged() {\n  let onCanvas = mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height;\n  return !onCanvas;\n}\n\nfunction windowResized() {\n  if (my.isRemote) {\n    return;\n  }\n  resizeCanvas(windowWidth, windowHeight);\n}\n\n  // console.log('windowResized width', width, 'height', height);\n\n\n// https://editor.p5js.org/jht9629-nyu/sketches/twgS6eWRZ\n// pixel-grid\n\n// https://editor.p5js.org/jht9629-nyu/sketches/7Wjlo3pPU\n// mo-pix-chip-grid jht9629 fireb_firebase.js\n\n// https://editor.p5js.org/jht9629-nyu/sketches/CntV1JQNp\n// p5moExamples pixel-grid 47\n\n// [x] Correct display of images - must hit show button\n// [x] Add --> Take, keep array of n images and upate\n// [x] photo_index\n\n// [x] my.photo_list - show only last n\n//    [ { name: \"\", index: n }, ... ]\n\n// [x] preserve image show order",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c78366f",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c78366f"
      },
      {
        "name": "photo.js",
        "content": "//\n\nfunction photo_name(index) {\n  return index.toString().padStart(3, '0') + my.imageExt;\n}\n\nfunction photo_list_entry(index) {\n  let name = photo_name(index);\n  let uid = my.uid;\n  return { name, index, uid };\n}\n\nfunction photo_path_entry(entry) {\n  return entry.uid + '/' + entry.name;\n}\n\nasync function photo_list_add(entry) {\n  my.photo_list.push(entry);\n  if (my.photo_list.length > my.photo_max) {\n    await photo_list_trim();\n  }\n\n  // Change to photo_list send to cloud\n  dbase_group_update({ photo_list: my.photo_list });\n}\n\nasync function photo_list_trim() {\n  //\n  // remove the first entry in photo_list\n  //\n  let first = my.photo_list.shift();\n  await photo_list_remove_entry(first);\n}\n\nasync function photo_list_remove_entry(entry) {\n  // console.log('photo_list_remove_entry entry', entry);\n\n  let path = photo_path_entry(entry);\n  try {\n    await fstorage_remove({ path });\n    remove_img_index(entry.index);\n  } catch (err) {\n    console.log('show_action err', err);\n  }\n}\n\nfunction remove_img_index(index) {\n  // console.log('remove_img_index index', index);\n  let id = 'id_img_' + index;\n  let img = select('#' + id);\n  // console.log('remove_img_index img', img);\n  if (img) {\n    img.remove();\n  }\n}\n\nasync function show_action() {\n  //\n  // console.log('show_action my.photo_list', my.photo_list);\n  for (let entry of my.photo_list) {\n    let path = photo_path_entry(entry);\n    try {\n      let url = await fstorage_download_url({ path });\n      url_result(url, entry.index);\n    } catch (err) {\n      console.log('show_action err', err);\n    }\n  }\n  function url_result(url, index) {\n    // console.log('url_result index', index, 'url', url);\n    let img = find_img(index);\n    img.elt.src = url;\n  }\n}\n\n// Create image element for an index\n//  or return if already present\n//\nfunction find_img(index) {\n  let id = 'id_img_' + index;\n  let img = select('#' + id);\n  if (!img) {\n    // console.log('show_action id', id);\n    img = createImg('', 'image');\n    img.id(id);\n    // console.log('show_action createImg', img);\n    // my.gallery_div.child(img);\n\n    // Add image as first child to see most recent first\n    my.gallery_div.elt.prepend(img.elt);\n\n    let iwidth = my.thumbWidth;\n    img.style('width: ' + iwidth + 'px;');\n  }\n  return img;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c783671",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c783671"
      },
      {
        "name": "ui_init.js",
        "content": "//\nfunction ui_init() {\n  //\n  my.effectBtn = ui_createButton('Effect');\n  my.effectBtn.mousePressed(effect_action);\n\n  my.takeBtn = ui_createButton('Take');\n  my.takeBtn.mousePressed(take_action);\n\n  my.removeBtn = ui_createButton('Remove');\n  my.removeBtn.mousePressed(remove_action);\n\n  my.showBtn = ui_createButton('Show');\n  my.showBtn.mousePressed(show_action);\n\n  my.photo_count_span = createSpan('' + my.photo_list.length);\n\n  my.gallery_div = ui_div_empty('igallery');\n}\n\nfunction effect_action() {\n  my.slit_scan = !my.slit_scan;\n}\n\nasync function take_action() {\n  // console.log('take_action');\n\n  let entry = photo_list_entry(my.photo_index + 1);\n  let path = photo_path_entry(entry);\n\n  let layer = my.canvas;\n  let imageQuality = my.imageQuality;\n  try {\n    await fstorage_upload({ path, layer, imageQuality });\n\n    await photo_list_add(entry);\n\n    dbase_group_update({ photo_index: dbase_increment(1) });\n    //\n  } catch (err) {\n    console.log('take_action err', err);\n  }\n}\n\nasync function remove_action() {\n  // console.log('remove_action photo_count', my.photo_list.length);\n  if (my.photo_list.length < 1) {\n    // No more images in the cloud\n    //  zero out photo_index\n    dbase_group_update({ photo_index: 0 });\n    return;\n  }\n  //\n  // remove the last entry in photo_list\n  //\n  let last = my.photo_list.pop();\n  await photo_list_remove_entry(last);\n\n  // Update photo_list in the cloud\n  dbase_group_update({ photo_list: my.photo_list });\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c783673",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c783673"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js\"></script>\n    <!-- <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js\"></script> -->\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://molab-itp.github.io/p5moRelease/lib/66/style.css\"></script>\n    <!-- <link rel=\"stylesheet\" type=\"text/css\" href=\"../../../p5moLibrary/src/lib/style.css?v=63\" /> -->\n\n    <style></style>\n  </head>\n  <body>\n    <main></main>\n\n    <script type=\"module\" src=\"https://molab-itp.github.io/p5moRelease/lib/70/a_lib.js\"></script>\n    <!-- <script type=\"module\" src=\"../../p5moLibrary/src/lib/a_lib.js\"></script> -->\n\n    <script src=\"a_my_init.js\"></script>\n    <script src=\"ui_init.js\"></script>\n    <script src=\"photo.js\"></script>\n    <script src=\"a_sketch.js\"></script>\n    <!-- ?v=63 included to force into the cache -->\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "661d5e46b5786e4d8c783670",
        "updatedAt": "2024-04-15T17:55:42.314Z",
        "createdAt": "2024-04-15T17:55:42.314Z",
        "isSelectedFile": false,
        "id": "661d5e46b5786e4d8c783670"
      }
    ],
    "createdAt": "2024-04-15T17:05:10.820Z",
    "updatedAt": "2024-04-15T17:55:42.314Z",
    "id": "-v7NuIZk5"
  }
]

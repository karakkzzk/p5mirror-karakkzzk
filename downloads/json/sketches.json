[
  {
    "name": "ims01-kara.z",
    "_id": "LYvffn-eM",
    "updatedAt": "2024-03-26T13:19:15.089Z",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "65f06cf03a9633050ec58359",
          "65f06cf03a9633050ec58358",
          "65f06cf03a9633050ec5835a"
        ],
        "fileType": "folder",
        "_id": "65f06cf03a9633050ec5835b",
        "createdAt": "2024-03-26T13:19:15.089Z",
        "updatedAt": "2024-03-26T13:19:15.089Z",
        "id": "65f06cf03a9633050ec5835b"
      },
      {
        "name": "sketch.js",
        "content": "//Attributes:\n//forked from: https://openprocessing.org/sketch/2122715\n//Comments:\n//The author utilizes a set of rules for the automated placement of stairs and floors, and enhances the structure with random decorative elements.\n//Key features:\n//- Building object that dynamically adjusts its form in response to user interactions (mouse clicks) to trigger the generation of new structures.\n//- Shader: adapted from https://openprocessing.org/sketch/1605869 to create a distinctive, stylized aesthetic reminiscent of pixel art or early computer graphics in the final render.\n//- Balance between randomness and structure.\n//- Challenges conventional notions of space and structure but also invites viewers to imagine the endless possibilities inherent in procedural generation\n\n//-----------------------------------------------------------\n// Labyrinth\n// For the WCCChallenge << Improbable architecture >>. Join the discord! https://discord.gg/S8c7qcjw2b\n\n// For this week I wanted to try some architectural designs inspired by Sander Patelski\n// (I love his \"Compositions\" series - https://shop.studiosanderpatelski.nl/), but as always,\n// ended up going in a completely different direction.\n// The buildings are generated following a simple set of rules for placing stairs and floors, then decorated with some random shapes. The building is then rendered and passed to a\n// dithering shader for a nice look\n// Dither shader adapted from https://openprocessing.org/sketch/1605869\n\nlet cw, ch;\nlet building;\nlet gl, test, theShader;\nlet isOrtho, bgGradient, cf;\n// Setup function: initializes the canvas, pixel density, background gradient,\n// the building object, and the shader for the dithering effect.\nfunction setup() {\n  cw = 1000; // Canvas width\n  ch = 1000; // Canvas height\n  createCanvas(cw, ch, WEBGL);\n  pixelDensity(1);\n  createBgGradient(); // Initializes background gradient\n  background(255); // Sets background color to white\n\n  building = new Building(); // Creates a new building object\n  theShader = createFilterShader(frag); // Initializes the dithering shader\n  cf = floor(random(1000)); // Random seed for color fluctuation\n}\n// Draw function: renders the building and applies visual effects each frame.\nfunction draw() {\n  // Set camera perspective\n  if (isOrtho) {\n    ortho();\n  } else {\n    perspective();\n  }\n  // Clear with white background\n  clear();\n  background(255);\n\n  // Draw and scale the background gradient\n  push();\n  translate(0, 0, -ch / 2);\n  scale(2, 2, 1);\n  image(bgGradient, -cw / 2, -ch / 2, cw, ch);\n  pop();\n\n  push();\n  // Position and rotate the building\n  rotateX(-PI / 12);\n  rotateY(PI / 4);\n  rotateY(frameCount * 0.005);\n\n  ambientLight(150);\n  directionalLight(255, 0, 0, 0.25, 0.25, -1);\n  pointLight(0, 255, 0, 0, 0, 0);\n  specularMaterial(200, 200, 200, 40);\n  building._3dDraw();\n  pop();\n\n  colorMode(HSB);\n  let hue = map(sin(frameCount * 0.0015 + cf), -1, 1, 0, 360);\n  let colors = color(hue, 100, 40)._array;\n  colorMode(RGB);\n\n  theShader.setUniform(\"uColor\", colors);\n  theShader.setUniform(\"resolution\", [cw, ch]);\n\n  filter(theShader);\n}\n\nlet opposites = {\n  up: \"down\",\n  down: \"up\",\n  left: \"right\",\n  right: \"left\",\n};\nclass Building {\n  constructor() {\n    this.w = floor(random(10, 12));\n    this.h = floor(random(10, 12));\n    this.numFloors = floor(random(10, 15));\n    this.xSize = random(50, 80);\n    this.zSize = random(50, 80);\n    this.ySize = random(80, 100);\n    this.floors = [];\n    this.initializeCells();\n    this.build();\n  }\n\n  initializeCells() {\n    for (let i = 0; i < this.numFloors; i++) {\n      let _floor = [];\n      for (let y = 0; y < this.h; y++) {\n        let _row = [];\n        for (let x = 0; x < this.w; x++) {\n          _row.push({\n            type: \"empty\",\n            x,\n            y,\n            floor: i,\n            decorations: [],\n          });\n        }\n        _floor.push(_row);\n      }\n      this.floors.push(_floor);\n    }\n  }\n\n  getCell(floor, x, y) {\n    if (floor < 0 || floor >= this.numFloors) {\n      return null;\n    }\n    let _floor = this.floors[floor];\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) {\n      return null;\n    }\n    return _floor[y][x];\n  }\n\n  build() {\n    let numFloors = this.numFloors;\n\n    for (let i = 0; i < numFloors; i++) {\n      this.restrictFloor(i);\n      this.populateFloor(i);\n      this.buildFloor(i);\n      if (i === numFloors - 1) {\n        this.cleanStairs(i); // Remove all stairs from last floor\n      }\n    }\n    // All cells that remain empty on the first floor, fill with floor\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(0, x, y);\n        if (cell.type === \"empty\" || cell.type === \"stairsEnd\") {\n          cell.type = \"floor\";\n        }\n      }\n    }\n    // Decorate floors\n    for (let i = 0; i < numFloors; i++) {\n      this.decorateFloor(i);\n    }\n  }\n\n  decorateFloor(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        // If cell is a floor type, and the cell below is also a floor type, add a column\n        let cell = this.getCell(_floorNumber, x, y);\n        let aboveCell = this.getCell(_floorNumber + 1, x, y);\n        if (cell.type === \"floor\" && aboveCell && aboveCell.type === \"floor\") {\n          if (random() < 0.8) {\n            cell.decorations.push({ type: \"column\" });\n          }\n        } else if (cell.type === \"floor\") {\n          if (random() < 0.2) {\n            let cx = random(0.3, 0.7);\n            let cy = random(0.3, 0.7);\n            let h = random(0.2, 0.3);\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 20;\n            let thickness = size / random(2, 4);\n            cell.decorations.push({ type: \"pot\", cx, cy, h, size, thickness });\n          } else if (random() < 0.2) {\n            let cx = random(0.3, 0.7);\n            let cy = random(0.3, 0.7);\n            let h = random(0.3, 0.7);\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 8;\n            let thickness = size / random(2, 4);\n            cell.decorations.push({\n              type: \"sphere\",\n              cx,\n              cy,\n              h,\n              size,\n              thickness,\n            });\n          } else if (random() < 0.15) {\n            cell.decorations.push({ type: \"box\", scale: random(0.7, 1.1) });\n          }\n        }\n      }\n    }\n  }\n\n  restrictFloor(_floorNumber) {\n    let numRingsX = map(_floorNumber, 0, this.numFloors, 0, this.w / 6);\n    let numRingsY = map(_floorNumber, 0, this.numFloors, 0, this.h / 6);\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y);\n        if (\n          x < numRingsX ||\n          x >= this.w - numRingsX ||\n          y < numRingsY ||\n          y >= this.h - numRingsY\n        ) {\n          cell.type = \"locked\";\n        }\n      }\n    }\n  }\n\n  cleanStairs(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y);\n        if (cell.type === \"stairs\") {\n          cell.type = \"empty\";\n        }\n      }\n    }\n  }\n\n  populateFloor(_floorNumber) {\n    if (_floorNumber === 0) {\n      return;\n    }\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let prevCell = this.getCell(_floorNumber - 1, x, y);\n        let cell = this.getCell(_floorNumber, x, y);\n        if (prevCell.type === \"stairsEnd\") {\n          cell.type = \"floor\";\n        }\n      }\n    }\n  }\n\n  buildFloor(_floorNumber) {\n    let requireGround = _floorNumber !== 0;\n    let maxTries = this.w * this.h * 5;\n    let stairsToAdd = floor(this.w * this.h * 0.33);\n    let totalStairs = 0;\n    let _floor = this.floors[_floorNumber];\n    let _prevFloor = _floorNumber > 0 ? this.floors[_floorNumber - 1] : null;\n    // Try to add stairs\n    while (totalStairs < stairsToAdd && maxTries > 0) {\n      let x = floor(random(this.w));\n      let y = floor(random(this.h));\n      let cell = this.getCell(_floorNumber, x, y);\n      let direction = random([\"up\", \"down\", \"left\", \"right\"]);\n      // Can place the stair if the cell is empty, and if the target cell\n      // (after following the direction) is empty and within the bounds of the floor\n      let canPlaceStair = cell.type === \"empty\";\n      let target = null;\n      let source = null;\n      let s = (source) => {\n        return (\n          source &&\n          (requireGround ? source.type === \"floor\" : source.type === \"empty\")\n        );\n      };\n      let f = (source) => {\n        // Check if previous floor has a stair on its source cell that is opposite direction to the current direction\n        if (_prevFloor) {\n          let prevCell = this.getCell(_floorNumber - 1, source.x, source.y);\n          if (prevCell.type === \"stairs\") {\n            return !prevCell.direction === opposites[direction];\n          }\n        }\n        return true;\n      };\n      switch (direction) {\n        case \"up\":\n          source = this.getCell(_floorNumber, x, y + 1);\n          target = this.getCell(_floorNumber, x, y - 1);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y > 0;\n          break;\n        case \"down\":\n          source = this.getCell(_floorNumber, x, y - 1);\n          target = this.getCell(_floorNumber, x, y + 1);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair &&\n            target &&\n            target.type === \"empty\" &&\n            y < this.h - 1;\n          break;\n        case \"left\":\n          source = this.getCell(_floorNumber, x + 1, y);\n          target = this.getCell(_floorNumber, x - 1, y);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x > 0;\n          break;\n        case \"right\":\n          source = this.getCell(_floorNumber, x - 1, y);\n          target = this.getCell(_floorNumber, x + 1, y);\n          canPlaceStair = canPlaceStair && s(source) && f(cell);\n          canPlaceStair =\n            canPlaceStair &&\n            target &&\n            target.type === \"empty\" &&\n            x < this.w - 1;\n          break;\n      }\n      if (canPlaceStair) {\n        cell.type = \"stairs\";\n        cell.direction = direction;\n        target.type = \"stairsEnd\";\n        totalStairs++;\n      }\n      maxTries--;\n    }\n\n    // For each empty cell, if it has a neighbor that is a floor, and there is no\n    // stairs on the floor below, make it a floor with a random diminishing chance\n    let chance = 0.6;\n    let numPasses = 3;\n    for (let i = 0; i < numPasses; i++) {\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(_floorNumber, x, y);\n          let stairsInPrevFloor =\n            !_prevFloor ||\n            this.getCell(_floorNumber - 1, x, y).type === \"stairs\";\n          if (cell.type === \"empty\" && !stairsInPrevFloor) {\n            let neighbors = this.getNeighbors(cell, _floor);\n            for (let neighbor of neighbors) {\n              if (neighbor.type === \"floor\" && random() < chance) {\n                cell.type = \"floor\";\n                cell.added = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n      chance *= 0.5;\n    }\n  }\n\n  getNeighbors(cell) {\n    let directions = [\n      [0, -1],\n      [0, 1],\n      [-1, 0],\n      [1, 0],\n    ];\n    return directions\n      .map((d) => {\n        let [dx, dy] = d;\n        return this.getCell(cell.floor, cell.x + dx, cell.y + dy);\n      })\n      .filter((c) => c);\n  }\n\n  _3dDraw(buffer) {\n    let xSize = this.xSize;\n    let ySize = this.ySize;\n    let zSize = this.zSize;\n    push();\n    // Translate so the building is centered\n    let totalW = this.w * xSize;\n    let totalH = this.floors.length * ySize;\n    let totalD = this.h * zSize;\n    translate(-totalW / 2, (totalH / 2) * 0.8, -totalD / 2);\n    for (let i = 0; i < this.floors.length; i++) {\n      push();\n      translate(0, -i * ySize, 0);\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(i, x, y);\n          push();\n          translate(cell.x * xSize, 0, cell.y * zSize);\n          stroke(\"#0C213A\");\n          let r = noise(cell.x, cell.y, i);\n          let sw = map(r, 0, 1, 0.5, 3);\n          strokeWeight(sw);\n\n          let c = r < 0.5 ? \"#303030\" : \"#909090\";\n          fill(c);\n\n          if (cell.type === \"floor\") {\n            this._drawFloor(buffer, cell);\n            this._drawDecor(buffer, cell);\n          } else if (cell.type === \"stairs\") {\n            this._drawStairs(buffer, cell);\n          }\n\n          pop();\n        }\n      }\n      pop();\n    }\n    pop();\n  }\n\n  _drawPot(buffer, d) {\n    let cx = d.cx * this.xSize;\n    let cy = d.cy * this.zSize;\n    let h = d.h * this.ySize;\n    push();\n    noStroke();\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2);\n    translate(cx, 0, cy);\n    let b = d.thickness;\n\n    // Bottom\n    push();\n    translate(0, h / 2, 0);\n    box(d.size, b, d.size);\n    pop();\n    // Left\n    push();\n    translate(-d.size / 2, 0, 0);\n    box(b, h, d.size);\n    pop();\n    // Right\n    push();\n    translate(d.size / 2, 0, 0);\n    box(b, h, d.size);\n    pop();\n    // Front\n    push();\n    translate(0, 0, -d.size / 2);\n    box(d.size, h, b);\n    pop();\n    // Back\n    push();\n    translate(0, 0, d.size / 2);\n    box(d.size, h, b);\n    pop();\n\n    pop();\n  }\n\n  _drawSphere(buffer, d) {\n    let cx = d.cx * this.xSize;\n    let cy = d.cy * this.zSize;\n    let h = d.h * this.ySize;\n    let b = d.thickness;\n    let speed = map(noise(d.cx, d.cy, d.h, frameCount * 0.01), 0, 1, 0.01, 0.1);\n    let r = map(sin(frameCount * speed), -1, 1, 0.8, 1.5);\n    push();\n    noStroke();\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2);\n    translate(cx, 0, cy);\n    translate(0, -h / 2, 0);\n    sphere(b * r);\n    pop();\n  }\n\n  _drawDecor(buffer, cell) {\n    for (let d of cell.decorations) {\n      switch (d.type) {\n        case \"column\":\n          push();\n          // Make a cylinder column in the middle of the cell\n          noStroke();\n          cylinder(max(this.xSize / 6, this.zSize / 6), this.ySize - 4);\n          pop();\n          break;\n        case \"pot\":\n          this._drawPot(buffer, d);\n          break;\n        case \"sphere\":\n          this._drawSphere(buffer, d);\n          break;\n        case \"box\":\n          push();\n          noFill();\n          // translate(-this.xSize / 2, this.ySize / 2, -this.ySize / 2)\n          scale(d.scale);\n          strokeWeight(1);\n          box(this.xSize, this.ySize, this.zSize);\n          pop();\n          break;\n      }\n    }\n  }\n\n  _drawStairs(buffer, cell) {\n    let numSteps = 10;\n    let width =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize;\n    let length =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize;\n    let stepSize = length / numSteps;\n    let stepHeight = this.ySize / numSteps;\n    push();\n    strokeWeight(1);\n    translate(0, this.ySize / 2, 0);\n    switch (cell.direction) {\n      case \"up\":\n        break;\n      case \"down\":\n        rotateY(PI);\n        break;\n      case \"left\":\n        rotateY(PI / 2);\n        break;\n      case \"right\":\n        rotateY(-PI / 2);\n        break;\n    }\n    for (let i = 0; i < numSteps; i++) {\n      push();\n      translate(0, 0, length / 2 - 2 * stepSize);\n      translate(0, -i * stepHeight, -i * stepSize + stepSize);\n      box(width, 4, stepSize * 2);\n      pop();\n    }\n    pop();\n  }\n\n  _drawStairs2(buffer, cell) {\n    push();\n    let e =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize;\n    let f =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize;\n    let d = sqrt(f * f + this.ySize * this.ySize);\n\n    switch (cell.direction) {\n      case \"up\":\n        break;\n      case \"down\":\n        rotateY(PI);\n        break;\n      case \"left\":\n        rotateY(PI / 2);\n        break;\n      case \"right\":\n        rotateY(-PI / 2);\n        break;\n    }\n    // Determine the angle of the plane, on the triangle formed by the diagonal of the box and the height\n    let angle = atan(this.ySize / f);\n    rotateX(-angle);\n    box(e, 2, d);\n    pop();\n  }\n\n  _drawFloor(buffer, cell) {\n    push();\n    translate(0, this.ySize / 2, 0);\n    if (cell.added) {\n      let d = noise(cell.x, cell.y, cell.floor, frameCount * 0.01);\n      if (d < 0.5) {\n        fill(\"#30303010\");\n      }\n    }\n    box(this.xSize, 2, this.zSize);\n    pop();\n  }\n\n  _drawArrow(x, y, direction) {\n    push();\n    translate(x, y);\n    switch (direction) {\n      case \"up\":\n        rotate(PI);\n        break;\n      case \"down\":\n        break;\n      case \"left\":\n        rotate(PI / 2);\n        break;\n      case \"right\":\n        rotate(-PI / 2);\n        break;\n    }\n    triangle(-5, -5, 5, -5, 0, 5);\n    pop();\n  }\n}\n\nlet createBgGradient = () => {\n  let graphics = createGraphics(cw, ch);\n  graphics.pixelDensity(1);\n  let gradient = graphics.drawingContext.createLinearGradient(\n    cw / 2,\n    0,\n    random(cw),\n    ch\n  );\n  gradient.addColorStop(0, \"#555\");\n  gradient.addColorStop(1, \"#AAA\");\n  graphics.drawingContext.fillStyle = gradient;\n  graphics.rect(0, 0, cw, ch);\n  bgGradient = graphics;\n};\n\nfunction keyPressed() {\n  if (key === \"s\") {\n    saveCanvas(\"screenshot\", \"png\");\n  } else if (key === \"o\") {\n    isOrtho = !isOrtho;\n  }\n}\n\n// Click to generate a new building\nfunction mouseClicked() {\n  building = new Building();\n  createBgGradient();\n  cf = floor(random(1000));\n}\n\n//==============================================================================\n// Shader\n//==============================================================================\n\n// Shader adapted from https://openprocessing.org/sketch/1605869\nlet frag = `\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform vec3 uColor;\nuniform sampler2D tex0;\n\nconst float Threshold = 0.5;\nconst float Multiplicator = 1.0 / 17.0;\nconst mat4 DitherMatrix = (mat4(\n    1, 13, 4, 16,\n    9, 5, 12, 8,\n    3, 15, 2, 14,\n    11, 7, 10, 6\n    ) - 8.) * Multiplicator;\n\nfloat GetLuminance(vec4 c) {\n  return (0.2126*c.r + 0.7152*c.g + 0.0722*c.b);\n}\n\nfloat AdjustDither( float val, vec2 coord ) {\n    vec2 coordMod = mod(coord, 4.0);\n    int xMod = int(coordMod.x);\n    int yMod = int(coordMod.y);\n\n    vec4 col;\n    if (xMod == 0) col = DitherMatrix[0];\n    else if (xMod == 1) col = DitherMatrix[1];\n    else if (xMod == 2) col = DitherMatrix[2];\n    else if (xMod == 3) col = DitherMatrix[3];\n\n    float adjustment = 0.;\n    if (yMod == 0) adjustment = col.x;\n    else if (yMod == 1) adjustment = col.y;\n    else if (yMod == 2) adjustment = col.z;\n    else if (yMod == 3) adjustment = col.w;\n\n    return val + (val * adjustment);\n}\n\nvoid main (void) {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec4 c = texture2D(tex0, uv);\n\n  float luminance = GetLuminance(c);\n\n  if (AdjustDither(luminance, uv*resolution)>Threshold) {\n    gl_FragColor = vec4(1., 1., 1., 1.);\n  } else {\n    // gl_FragColor = vec4(0., 0., 0., 1.);\n    gl_FragColor = vec4(uColor, 1.);\n  }\n}`;\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec58358",
        "isSelectedFile": true,
        "createdAt": "2024-03-26T13:19:15.089Z",
        "updatedAt": "2024-03-26T13:19:15.089Z",
        "id": "65f06cf03a9633050ec58358"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/addons/p5.sound.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n    <meta charset=\"utf-8\" />\n\n  </head>\n  <body>\n    <main>\n    </main>\n    <script src=\"sketch.js\"></script>\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec58359",
        "createdAt": "2024-03-26T13:19:15.089Z",
        "updatedAt": "2024-03-26T13:19:15.089Z",
        "id": "65f06cf03a9633050ec58359"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "65f06cf03a9633050ec5835a",
        "createdAt": "2024-03-26T13:19:15.089Z",
        "updatedAt": "2024-03-26T13:19:15.089Z",
        "id": "65f06cf03a9633050ec5835a"
      }
    ],
    "createdAt": "2024-03-12T15:39:43.874Z",
    "id": "LYvffn-eM"
  },
  {
    "name": "Innovative crafter",
    "_id": "OcjJ4foZE",
    "updatedAt": "2024-03-26T02:11:14.564Z",
    "files": [
      {
        "name": "root",
        "content": "",
        "children": [
          "66021dabfbc17f1fd20ddb17",
          "66021dabfbc17f1fd20ddb16",
          "66021dabfbc17f1fd20ddb18"
        ],
        "fileType": "folder",
        "_id": "66021dabfbc17f1fd20ddb19",
        "createdAt": "2024-03-26T02:11:14.564Z",
        "updatedAt": "2024-03-26T02:11:14.564Z",
        "id": "66021dabfbc17f1fd20ddb19"
      },
      {
        "name": "sketch.js",
        "content": "\n//Attributes:\n//forked from: https://openprocessing.org/sketch/2122715\n//Comments:\n//The author utilizes a set of rules for the automated placement of stairs and floors, and enhances the structure with random decorative elements.\n//Key features: \n//- Building object that dynamically adjusts its form in response to user interactions (mouse clicks) to trigger the generation of new structures.\n//- Shader: adapted from https://openprocessing.org/sketch/1605869 to create a distinctive, stylized aesthetic reminiscent of pixel art or early computer graphics in the final render.\n//- Balance between randomness and structure.\n//- Challenges conventional notions of space and structure but also invites viewers to imagine the endless possibilities inherent in procedural generation\n\n\n\n//-----------------------------------------------------------\n// Labyrinth\n// For the WCCChallenge << Improbable architecture >>. Join the discord! https://discord.gg/S8c7qcjw2b\n\n// For this week I wanted to try some architectural designs inspired by Sander Patelski \n// (I love his \"Compositions\" series - https://shop.studiosanderpatelski.nl/), but as always,\n// ended up going in a completely different direction.\n// The buildings are generated following a simple set of rules for placing stairs and floors,\n// then decorated with some random shapes. The building is then rendered and passed to a\n// dithering shader for a nice look\n// Dither shader adapted from https://openprocessing.org/sketch/1605869\n\nlet cw, ch\nlet building\nlet gl, test, theShader\nlet isOrtho, bgGradient, cf\nfunction setup() {\n  cw = 1000\n  ch = 1000\n  createCanvas(cw, ch, WEBGL)\n  pixelDensity(1)\n  createBgGradient()\n  background(255)\n\n  building = new Building()\n  theShader = createFilterShader(frag)\n  cf = floor(random(1000))\n}\n\nfunction draw() {\n  if (isOrtho) {\n    ortho()\n  } else {\n    perspective()\n  }\n\n  clear()\n  background(255)\n  push()\n  translate(0, 0, -ch / 2)\n  scale(2, 2, 1)\n  image(bgGradient, -cw / 2, -ch / 2, cw, ch)\n  pop()\n\n  push()\n  rotateX(-PI / 12)\n  rotateY(PI / 4)\n  rotateY(frameCount * 0.005)\n\n  ambientLight(150)\n  directionalLight(255, 0, 0, 0.25, 0.25, -1)\n  pointLight(0, 255, 0, 0, 0, 0)\n  specularMaterial(200, 200, 200, 40)\n  building._3dDraw()\n  pop()\n\n  colorMode(HSB)\n  let hue = map(sin(frameCount * 0.0015 + cf), -1, 1, 0, 360)\n  let colors = color(hue, 100, 40)._array\n  colorMode(RGB)\n\n  theShader.setUniform(\"uColor\", colors)\n  theShader.setUniform(\"resolution\", [cw, ch])\n\n  filter(theShader)\n}\n\nlet opposites = {\n  up: \"down\",\n  down: \"up\",\n  left: \"right\",\n  right: \"left\",\n}\nclass Building {\n  constructor() {\n    this.w = floor(random(10, 12))\n    this.h = floor(random(10, 12))\n    this.numFloors = floor(random(10, 15))\n    this.xSize = random(50, 80)\n    this.zSize = random(50, 80)\n    this.ySize = random(80, 100)\n    this.floors = []\n    this.initializeCells()\n    this.build()\n  }\n\n  initializeCells() {\n    for (let i = 0; i < this.numFloors; i++) {\n      let _floor = []\n      for (let y = 0; y < this.h; y++) {\n        let _row = []\n        for (let x = 0; x < this.w; x++) {\n          _row.push({\n            type: \"empty\",\n            x,\n            y,\n            floor: i,\n            decorations: [],\n          })\n        }\n        _floor.push(_row)\n      }\n      this.floors.push(_floor)\n    }\n  }\n\n  getCell(floor, x, y) {\n    if (floor < 0 || floor >= this.numFloors) {\n      return null\n    }\n    let _floor = this.floors[floor]\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) {\n      return null\n    }\n    return _floor[y][x]\n  }\n\n  build() {\n    let numFloors = this.numFloors\n\n    for (let i = 0; i < numFloors; i++) {\n      this.restrictFloor(i)\n      this.populateFloor(i)\n      this.buildFloor(i)\n      if (i === numFloors - 1) {\n        this.cleanStairs(i) // Remove all stairs from last floor\n      }\n    }\n    // All cells that remain empty on the first floor, fill with floor\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(0, x, y)\n        if (cell.type === \"empty\" || cell.type === \"stairsEnd\") {\n          cell.type = \"floor\"\n        }\n      }\n    }\n    // Decorate floors\n    for (let i = 0; i < numFloors; i++) {\n      this.decorateFloor(i)\n    }\n  }\n\n  decorateFloor(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        // If cell is a floor type, and the cell below is also a floor type, add a column\n        let cell = this.getCell(_floorNumber, x, y)\n        let aboveCell = this.getCell(_floorNumber + 1, x, y)\n        if (cell.type === \"floor\" && aboveCell && aboveCell.type === \"floor\") {\n          if (random() < 0.8) {\n            cell.decorations.push({ type: \"column\" })\n          }\n        } else if (cell.type === \"floor\") {\n          if (random() < 0.2) {\n            let cx = random(0.3, 0.7)\n            let cy = random(0.3, 0.7)\n            let h = random(0.2, 0.3)\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 20\n            let thickness = size / random(2, 4)\n            cell.decorations.push({ type: \"pot\", cx, cy, h, size, thickness })\n          } else if (random() < 0.2) {\n            let cx = random(0.3, 0.7)\n            let cy = random(0.3, 0.7)\n            let h = random(0.3, 0.7)\n            let size = (max(this.xSize, this.ySize) * random(2, 5)) / 8\n            let thickness = size / random(2, 4)\n            cell.decorations.push({\n              type: \"sphere\",\n              cx,\n              cy,\n              h,\n              size,\n              thickness,\n            })\n          } else if (random() < 0.15) {\n            cell.decorations.push({ type: \"box\", scale: random(0.7, 1.1) })\n          }\n        }\n      }\n    }\n  }\n\n  restrictFloor(_floorNumber) {\n    let numRingsX = map(_floorNumber, 0, this.numFloors, 0, this.w / 6)\n    let numRingsY = map(_floorNumber, 0, this.numFloors, 0, this.h / 6)\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y)\n        if (\n          x < numRingsX ||\n          x >= this.w - numRingsX ||\n          y < numRingsY ||\n          y >= this.h - numRingsY\n        ) {\n          cell.type = \"locked\"\n        }\n      }\n    }\n  }\n\n  cleanStairs(_floorNumber) {\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let cell = this.getCell(_floorNumber, x, y)\n        if (cell.type === \"stairs\") {\n          cell.type = \"empty\"\n        }\n      }\n    }\n  }\n\n  populateFloor(_floorNumber) {\n    if (_floorNumber === 0) {\n      return\n    }\n    for (let y = 0; y < this.h; y++) {\n      for (let x = 0; x < this.w; x++) {\n        let prevCell = this.getCell(_floorNumber - 1, x, y)\n        let cell = this.getCell(_floorNumber, x, y)\n        if (prevCell.type === \"stairsEnd\") {\n          cell.type = \"floor\"\n        }\n      }\n    }\n  }\n\n  buildFloor(_floorNumber) {\n    let requireGround = _floorNumber !== 0\n    let maxTries = this.w * this.h * 5\n    let stairsToAdd = floor(this.w * this.h * 0.33)\n    let totalStairs = 0\n    let _floor = this.floors[_floorNumber]\n    let _prevFloor = _floorNumber > 0 ? this.floors[_floorNumber - 1] : null\n    // Try to add stairs\n    while (totalStairs < stairsToAdd && maxTries > 0) {\n      let x = floor(random(this.w))\n      let y = floor(random(this.h))\n      let cell = this.getCell(_floorNumber, x, y)\n      let direction = random([\"up\", \"down\", \"left\", \"right\"])\n      // Can place the stair if the cell is empty, and if the target cell\n      // (after following the direction) is empty and within the bounds of the floor\n      let canPlaceStair = cell.type === \"empty\"\n      let target = null\n      let source = null\n      let s = (source) => {\n        return (\n          source &&\n          (requireGround ? source.type === \"floor\" : source.type === \"empty\")\n        )\n      }\n      let f = (source) => {\n        // Check if previous floor has a stair on its source cell that is opposite direction to the current direction\n        if (_prevFloor) {\n          let prevCell = this.getCell(_floorNumber - 1, source.x, source.y)\n          if (prevCell.type === \"stairs\") {\n            return !prevCell.direction === opposites[direction]\n          }\n        }\n        return true\n      }\n      switch (direction) {\n        case \"up\":\n          source = this.getCell(_floorNumber, x, y + 1)\n          target = this.getCell(_floorNumber, x, y - 1)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y > 0\n          break\n        case \"down\":\n          source = this.getCell(_floorNumber, x, y - 1)\n          target = this.getCell(_floorNumber, x, y + 1)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && y < this.h - 1\n          break\n        case \"left\":\n          source = this.getCell(_floorNumber, x + 1, y)\n          target = this.getCell(_floorNumber, x - 1, y)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x > 0\n          break\n        case \"right\":\n          source = this.getCell(_floorNumber, x - 1, y)\n          target = this.getCell(_floorNumber, x + 1, y)\n          canPlaceStair = canPlaceStair && s(source) && f(cell)\n          canPlaceStair =\n            canPlaceStair && target && target.type === \"empty\" && x < this.w - 1\n          break\n      }\n      if (canPlaceStair) {\n        cell.type = \"stairs\"\n        cell.direction = direction\n        target.type = \"stairsEnd\"\n        totalStairs++\n      }\n      maxTries--\n    }\n\n    // For each empty cell, if it has a neighbor that is a floor, and there is no\n    // stairs on the floor below, make it a floor with a random diminishing chance\n    let chance = 0.6\n    let numPasses = 3\n    for (let i = 0; i < numPasses; i++) {\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(_floorNumber, x, y)\n          let stairsInPrevFloor =\n            !_prevFloor ||\n            this.getCell(_floorNumber - 1, x, y).type === \"stairs\"\n          if (cell.type === \"empty\" && !stairsInPrevFloor) {\n            let neighbors = this.getNeighbors(cell, _floor)\n            for (let neighbor of neighbors) {\n              if (neighbor.type === \"floor\" && random() < chance) {\n                cell.type = \"floor\"\n                cell.added = true\n                break\n              }\n            }\n          }\n        }\n      }\n      chance *= 0.5\n    }\n  }\n\n  getNeighbors(cell) {\n    let directions = [\n      [0, -1],\n      [0, 1],\n      [-1, 0],\n      [1, 0],\n    ]\n    return directions\n      .map((d) => {\n        let [dx, dy] = d\n        return this.getCell(cell.floor, cell.x + dx, cell.y + dy)\n      })\n      .filter((c) => c)\n  }\n\n  _3dDraw(buffer) {\n    let xSize = this.xSize\n    let ySize = this.ySize\n    let zSize = this.zSize\n    push()\n    // Translate so the building is centered\n    let totalW = this.w * xSize\n    let totalH = this.floors.length * ySize\n    let totalD = this.h * zSize\n    translate(-totalW / 2, (totalH / 2) * 0.8, -totalD / 2)\n    for (let i = 0; i < this.floors.length; i++) {\n      push()\n      translate(0, -i * ySize, 0)\n      for (let y = 0; y < this.h; y++) {\n        for (let x = 0; x < this.w; x++) {\n          let cell = this.getCell(i, x, y)\n          push()\n          translate(cell.x * xSize, 0, cell.y * zSize)\n          stroke(\"#0C213A\")\n          let r = noise(cell.x, cell.y, i)\n          let sw = map(r, 0, 1, 0.5, 3)\n          strokeWeight(sw)\n\n          let c = r < 0.5 ? \"#303030\" : \"#909090\"\n          fill(c)\n\n          if (cell.type === \"floor\") {\n            this._drawFloor(buffer, cell)\n            this._drawDecor(buffer, cell)\n          } else if (cell.type === \"stairs\") {\n            this._drawStairs(buffer, cell)\n          }\n\n          pop()\n        }\n      }\n      pop()\n    }\n    pop()\n  }\n\n  _drawPot(buffer, d) {\n    let cx = d.cx * this.xSize\n    let cy = d.cy * this.zSize\n    let h = d.h * this.ySize\n    push()\n    noStroke()\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2)\n    translate(cx, 0, cy)\n    let b = d.thickness\n\n    // Bottom\n    push()\n    translate(0, h / 2, 0)\n    box(d.size, b, d.size)\n    pop()\n    // Left\n    push()\n    translate(-d.size / 2, 0, 0)\n    box(b, h, d.size)\n    pop()\n    // Right\n    push()\n    translate(d.size / 2, 0, 0)\n    box(b, h, d.size)\n    pop()\n    // Front\n    push()\n    translate(0, 0, -d.size / 2)\n    box(d.size, h, b)\n    pop()\n    // Back\n    push()\n    translate(0, 0, d.size / 2)\n    box(d.size, h, b)\n    pop()\n\n    pop()\n  }\n\n  _drawSphere(buffer, d) {\n    let cx = d.cx * this.xSize\n    let cy = d.cy * this.zSize\n    let h = d.h * this.ySize\n    let b = d.thickness\n    let speed = map(noise(d.cx, d.cy, d.h, frameCount * 0.01), 0, 1, 0.01, 0.1)\n    let r = map(sin(frameCount * speed), -1, 1, 0.8, 1.5)\n    push()\n    noStroke()\n    translate(-this.xSize / 2, this.ySize / 2 - h / 2, -this.ySize / 2)\n    translate(cx, 0, cy)\n    translate(0, -h / 2, 0)\n    sphere(b * r)\n    pop()\n  }\n\n  _drawDecor(buffer, cell) {\n    for (let d of cell.decorations) {\n      switch (d.type) {\n        case \"column\":\n          push()\n          // Make a cylinder column in the middle of the cell\n          noStroke()\n          cylinder(max(this.xSize / 6, this.zSize / 6), this.ySize - 4)\n          pop()\n          break\n        case \"pot\":\n          this._drawPot(buffer, d)\n          break\n        case \"sphere\":\n          this._drawSphere(buffer, d)\n          break\n        case \"box\":\n          push()\n          noFill()\n          // translate(-this.xSize / 2, this.ySize / 2, -this.ySize / 2)\n          scale(d.scale)\n          strokeWeight(1)\n          box(this.xSize, this.ySize, this.zSize)\n          pop()\n          break\n      }\n    }\n  }\n\n  _drawStairs(buffer, cell) {\n    let numSteps = 10\n    let width =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize\n    let length =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize\n    let stepSize = length / numSteps\n    let stepHeight = this.ySize / numSteps\n    push()\n    strokeWeight(1)\n    translate(0, this.ySize / 2, 0)\n    switch (cell.direction) {\n      case \"up\":\n        break\n      case \"down\":\n        rotateY(PI)\n        break\n      case \"left\":\n        rotateY(PI / 2)\n        break\n      case \"right\":\n        rotateY(-PI / 2)\n        break\n    }\n    for (let i = 0; i < numSteps; i++) {\n      push()\n      translate(0, 0, length / 2 - 2 * stepSize)\n      translate(0, -i * stepHeight, -i * stepSize + stepSize)\n      box(width, 4, stepSize * 2)\n      pop()\n    }\n    pop()\n  }\n\n  _drawStairs2(buffer, cell) {\n    push()\n    let e =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.xSize\n        : this.zSize\n    let f =\n      cell.direction === \"up\" || cell.direction === \"down\"\n        ? this.zSize\n        : this.xSize\n    let d = sqrt(f * f + this.ySize * this.ySize)\n\n    switch (cell.direction) {\n      case \"up\":\n        break\n      case \"down\":\n        rotateY(PI)\n        break\n      case \"left\":\n        rotateY(PI / 2)\n        break\n      case \"right\":\n        rotateY(-PI / 2)\n        break\n    }\n    // Determine the angle of the plane, on the triangle formed by the diagonal of the box and the height\n    let angle = atan(this.ySize / f)\n    rotateX(-angle)\n    box(e, 2, d)\n    pop()\n  }\n\n  _drawFloor(buffer, cell) {\n    push()\n    translate(0, this.ySize / 2, 0)\n    if (cell.added) {\n      let d = noise(cell.x, cell.y, cell.floor, frameCount * 0.01)\n      if (d < 0.5) {\n        fill(\"#30303010\")\n      }\n    }\n    box(this.xSize, 2, this.zSize)\n    pop()\n  }\n\n  _drawArrow(x, y, direction) {\n    push()\n    translate(x, y)\n    switch (direction) {\n      case \"up\":\n        rotate(PI)\n        break\n      case \"down\":\n        break\n      case \"left\":\n        rotate(PI / 2)\n        break\n      case \"right\":\n        rotate(-PI / 2)\n        break\n    }\n    triangle(-5, -5, 5, -5, 0, 5)\n    pop()\n  }\n}\n\nlet createBgGradient = () => {\n  let graphics = createGraphics(cw, ch)\n  graphics.pixelDensity(1)\n  let gradient = graphics.drawingContext.createLinearGradient(\n    cw / 2,\n    0,\n    random(cw),\n    ch\n  )\n  gradient.addColorStop(0, \"#555\")\n  gradient.addColorStop(1, \"#AAA\")\n  graphics.drawingContext.fillStyle = gradient\n  graphics.rect(0, 0, cw, ch)\n  bgGradient = graphics\n}\n\nfunction keyPressed() {\n  if (key === \"s\") {\n    saveCanvas(\"screenshot\", \"png\")\n  } else if (key === \"o\") {\n    isOrtho = !isOrtho\n  }\n}\n\n// Click to generate a new building\nfunction mouseClicked() {\n  building = new Building()\n  createBgGradient()\n  cf = floor(random(1000))\n}\n    \n\n\n//==============================================================================\n// Shader\n//==============================================================================\n\n// Shader adapted from https://openprocessing.org/sketch/1605869\nlet frag = `\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform vec3 uColor;\nuniform sampler2D tex0;\n\nconst float Threshold = 0.5;\nconst float Multiplicator = 1.0 / 17.0;\nconst mat4 DitherMatrix = (mat4(\n    1, 13, 4, 16,\n    9, 5, 12, 8,\n    3, 15, 2, 14,\n    11, 7, 10, 6\n    ) - 8.) * Multiplicator;\n\nfloat GetLuminance(vec4 c) {\n  return (0.2126*c.r + 0.7152*c.g + 0.0722*c.b);\n}\n\nfloat AdjustDither( float val, vec2 coord ) {\n    vec2 coordMod = mod(coord, 4.0);\n    int xMod = int(coordMod.x);\n    int yMod = int(coordMod.y);\n\n    vec4 col;\n    if (xMod == 0) col = DitherMatrix[0];\n    else if (xMod == 1) col = DitherMatrix[1];\n    else if (xMod == 2) col = DitherMatrix[2];\n    else if (xMod == 3) col = DitherMatrix[3];\n\n    float adjustment = 0.;\n    if (yMod == 0) adjustment = col.x;\n    else if (yMod == 1) adjustment = col.y;\n    else if (yMod == 2) adjustment = col.z;\n    else if (yMod == 3) adjustment = col.w;\n\n    return val + (val * adjustment);\n}\n\nvoid main (void) {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec4 c = texture2D(tex0, uv);\n\n  float luminance = GetLuminance(c);\n\n  if (AdjustDither(luminance, uv*resolution)>Threshold) {\n    gl_FragColor = vec4(1., 1., 1., 1.);\n  } else {\n    // gl_FragColor = vec4(0., 0., 0., 1.);\n    gl_FragColor = vec4(uColor, 1.);\n  }\n}`\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb16",
        "isSelectedFile": true,
        "createdAt": "2024-03-26T02:11:14.564Z",
        "updatedAt": "2024-03-26T02:11:14.564Z",
        "id": "66021dabfbc17f1fd20ddb16"
      },
      {
        "name": "index.html",
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.1/addons/p5.sound.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n    <meta charset=\"utf-8\" />\n\n  </head>\n  <body>\n    <main>\n    </main>\n    <script src=\"sketch.js\"></script>\n  </body>\n</html>\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb17",
        "createdAt": "2024-03-26T02:11:14.564Z",
        "updatedAt": "2024-03-26T02:11:14.564Z",
        "id": "66021dabfbc17f1fd20ddb17"
      },
      {
        "name": "style.css",
        "content": "html, body {\n  margin: 0;\n  padding: 0;\n}\ncanvas {\n  display: block;\n}\n",
        "children": [],
        "fileType": "file",
        "_id": "66021dabfbc17f1fd20ddb18",
        "createdAt": "2024-03-26T02:11:14.564Z",
        "updatedAt": "2024-03-26T02:11:14.564Z",
        "id": "66021dabfbc17f1fd20ddb18"
      }
    ],
    "createdAt": "2024-03-26T02:11:14.564Z",
    "id": "OcjJ4foZE"
  }
]
